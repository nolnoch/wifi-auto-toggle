Index: AndroidManifest.xml
===================================================================
--- AndroidManifest.xml	(revision 14)
+++ AndroidManifest.xml	(working copy)
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.groza.wifiauto"
-    android:versionCode="14"
-    android:versionName="2.4.2" >
+    package="com.nolnoch.wifiauto"
+    android:versionCode="15"
+    android:versionName="2.5.0" >
 
     <uses-sdk android:minSdkVersion="7" android:targetSdkVersion="7"/>
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
@@ -10,14 +10,15 @@
 	<uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
 	<uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/>
 	<uses-permission android:name="android.permission.INTERNET" />
-	<uses-permission android:name="android.permission.READ_CONTACTS"/>
+	<uses-permission android:name="android.permission.READ_CONTACTS"/>
+	<uses-permission android:name="com.android.vending.CHECK_LICENSE"/>
     
     <application
         android:icon="@drawable/ic_launcher_wat"
         android:label="@string/app_name" android:debuggable="false" android:allowBackup="true">
         <uses-library android:name="com.google.android.maps" />
 		<receiver
-		    android:name=".CustomReceiver"
+		    android:name="com.nolnoch.wifiauto.CustomReceiver"
 		    android:enabled="false" >
   			<intent-filter>
     			<action android:name="android.intent.action.USER_PRESENT" />
@@ -52,10 +53,7 @@
         <activity
             android:label="@string/app_name"
             android:name=".SQLAdapter" />
-        <activity
-            android:label="@string/app_name"
-            android:name="com.groza.firstapp.ProximityIntentReceiver" />
         <service
-            android:name="com.groza.wifiauto.ProximityMachine" />
+            android:name="com.nolnoch.wifiauto.ProximityMachine" />
     </application>
 </manifest>
\ No newline at end of file
Index: project.properties
===================================================================
--- project.properties	(revision 3)
+++ project.properties	(working copy)
@@ -9,3 +9,4 @@
 
 # Project target.
 target=Google Inc.:Google APIs:7
+android.library.reference.1=../../../../../home/nolnoch/android/android_licensing/library
Index: res/layout/editdialog.xml
===================================================================
--- res/layout/editdialog.xml	(revision 10)
+++ res/layout/editdialog.xml	(working copy)
@@ -11,6 +11,7 @@
         android:layout_height="wrap_content"
         android:padding="16dp"
         android:text="@string/edit_details"
+        android:textColor="#00b595"
         android:textSize="24sp" />
     
     <TextView
Index: res/layout/mapdialog.xml
===================================================================
--- res/layout/mapdialog.xml	(revision 3)
+++ res/layout/mapdialog.xml	(working copy)
@@ -12,6 +12,7 @@
         android:gravity="center_horizontal"
         android:padding="18dp"
         android:text="@string/correct_loc"
+        android:textColor="#00b595"
         android:textSize="24sp" />
 
     <LinearLayout
Index: src/com/groza/wifiauto/AutomaticActivity.java
===================================================================
--- src/com/groza/wifiauto/AutomaticActivity.java	(revision 13)
+++ src/com/groza/wifiauto/AutomaticActivity.java	(working copy)
@@ -1,188 +0,0 @@
-package com.groza.wifiauto;
-
-import android.app.Activity;
-import android.app.ProgressDialog;
-import android.content.Context;
-import android.content.Intent;
-import android.location.Location;
-import android.location.LocationListener;
-import android.location.LocationManager;
-import android.net.wifi.WifiManager;
-import android.os.Bundle;
-import android.os.CountDownTimer;
-import android.util.Log;
-import android.view.View;
-import android.widget.TabHost;
-import android.widget.Toast;
-
-public class AutomaticActivity extends Activity {
-	//Anchor Wifi and GPS service connections.
-	public static WifiManager wifiManager;
-	public static LocationManager locationManager;
-    
-    public static Location finalLocation;
-    public static LocationListener locationListener; 
-	public static int tick = 0;
-	private static final int TWO_MINUTES = 120000;
-	private static final int AUTO_RESULT = 1060;
-	private static final long ONE_SECOND = 1000;
-	private static double coordLat;
-	private static double coordLong;
-	private static boolean ticktock = false;
-	
-	private static ProgressDialog searching;
-	
-	private CountDownTimer timeout = new CountDownTimer(ONE_SECOND*40, ONE_SECOND) {
-	     public void onTick(long remainder) {}
-
-	     public void onFinish() {
-	    	endListener();
-	    	ticktock = false;
-	    	if (finalLocation != null) {
-				process(); }
-			else {Toast.makeText(getApplicationContext(), "Network timeout. Please try again.", Toast.LENGTH_SHORT).show(); }
-	     }
-	  };
-	
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.autopage);
-        
-		wifiManager = (WifiManager) this.getSystemService(Context.WIFI_SERVICE);
-		locationManager = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE);
-        
-    	finalLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
-    	
-	}
-	
-	//Define method called by Button click.
-    public void locateMe(View view) {
-    	
-    	searching = ProgressDialog.show(AutomaticActivity.this, "", 
-                "Searching...", true);
-    	
-    	locationListener = new LocationListener() {
-    		public void onLocationChanged(Location location) {
-    			if (isBetterLocation(location, finalLocation)) {
-    	    		finalLocation = location; }
-    			tick++;
-    			if (tick >= 3) {
-    				timeout.cancel();
-    				endListener();
-    				if (finalLocation != null) {
-    					process(); }
-    				else {
-    					Toast.makeText(getApplicationContext(), "No location found.", Toast.LENGTH_SHORT).show(); }
-    			}
-    		}
-    		public void onStatusChanged(String provider, int status, Bundle extras) {}
-    		public void onProviderEnabled(String provider) {}
-    		public void onProviderDisabled(String provider) {}
-    	};
-    	    	
-    	locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0, locationListener);
-    	locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);
-    	  
-    	timeout.start();
-    	ticktock = true;
-    }
-    
-    /** Determines whether one Location reading is better than the current Location fix
-      * @param location  The new Location that you want to evaluate
-      * @param currentBestLocation  The current Location fix, to which you want to compare the new one
-      */
-    protected boolean isBetterLocation(Location location, Location currentBestLocation) {
-        if (currentBestLocation == null) {
-            // A new location is always better than no location
-            return true;
-        }
-
-        // Check whether the new location fix is newer or older
-        long timeDelta = location.getTime() - currentBestLocation.getTime();
-        boolean isSignificantlyNewer = timeDelta > TWO_MINUTES;
-        boolean isSignificantlyOlder = timeDelta < -TWO_MINUTES;
-        boolean isNewer = timeDelta > 0;
-
-        // If it's been more than two minutes since the current location, use the new location
-        // because the user has likely moved
-        if (isSignificantlyNewer) {
-            return true;
-        // If the new location is more than two minutes older, it must be worse
-        } else if (isSignificantlyOlder) {
-            return false;
-        }
-
-        // Check whether the new location fix is more or less accurate
-        int accuracyDelta = (int) (location.getAccuracy() - currentBestLocation.getAccuracy());
-        boolean isLessAccurate = accuracyDelta > 0;
-        boolean isMoreAccurate = accuracyDelta < 0;
-        boolean isSignificantlyLessAccurate = accuracyDelta > 200;
-
-        // Check if the old and new location are from the same provider
-        boolean isFromSameProvider = isSameProvider(location.getProvider(),
-                currentBestLocation.getProvider());
-
-        // Determine location quality using a combination of timeliness and accuracy
-        if (isMoreAccurate) {
-            return true;
-        } else if (isNewer && !isLessAccurate) {
-            return true;
-        } else if (isNewer && !isSignificantlyLessAccurate && isFromSameProvider) {
-            return true;
-        }
-        return false;
-    }
-
-    /** Checks whether two providers are the same */
-    private boolean isSameProvider(String provider1, String provider2) {
-        if (provider1 == null) {
-          return provider2 == null;
-        }
-        return provider1.equals(provider2);
-    }
-    
-    public void endListener() {
-    	locationManager.removeUpdates(locationListener);
-    	searching.dismiss();
-		tick = 0;
-    }
-    
-    public void process() {
-    	coordLat = finalLocation.getLatitude();
-		coordLong = finalLocation.getLongitude();
-		
-		Intent intent = new Intent(AutomaticActivity.this, MapFrameActivity.class);
-		intent.putExtra("latitude", coordLat);
-		intent.putExtra("longitude", coordLong);
-		startActivityForResult(intent, AUTO_RESULT);
-    }
-    
-    @Override
-	public void onActivityResult(int requestCode, int resultCode, Intent intent) {
-		if (resultCode == RESULT_OK) {
-			switch (requestCode) {
-			case AUTO_RESULT:
-				TabHost tabHost =  (TabHost) getParent().findViewById(android.R.id.tabhost);
-	            tabHost.setCurrentTab(2);
-				break;
-			default:
-				Log.w("DEBUG", "Activity not prepared to handle request");
-				break;
-			}
-		} else {
-			Log.w("DEBUG", "Activity result not OK");
-		}
-	}
-    
-    @Override
-	protected void onPause() {
-    	if (ticktock) {
-    		timeout.cancel();
-    		endListener(); }
-    	super.onPause();
-	}
-	@Override
-	protected void onResume() {
-		super.onResume();
-	}
-}
\ No newline at end of file
Index: src/com/groza/wifiauto/CustomReceiver.java
===================================================================
--- src/com/groza/wifiauto/CustomReceiver.java	(revision 3)
+++ src/com/groza/wifiauto/CustomReceiver.java	(working copy)
@@ -1,14 +0,0 @@
-package com.groza.wifiauto;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-
-public class CustomReceiver extends BroadcastReceiver {
-
-	@Override
-	public void onReceive(Context context, Intent intent) {
-		context.startService(new Intent(context, ProximityMachine.class));
-	}
-
-}
Index: src/com/groza/wifiauto/ManageActivity.java
===================================================================
--- src/com/groza/wifiauto/ManageActivity.java	(revision 14)
+++ src/com/groza/wifiauto/ManageActivity.java	(working copy)
@@ -1,136 +0,0 @@
-package com.groza.wifiauto;
-
-import android.app.ListActivity;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.database.Cursor;
-import android.os.Bundle;
-import android.view.View;
-import android.widget.Button;
-import android.widget.CheckedTextView;
-import android.widget.ListView;
-import android.widget.SimpleCursorAdapter;
-import android.widget.TextView;
-
-public class ManageActivity extends ListActivity {
-	private SQLAdapter sqlAdapter;
-	private Cursor sqlCursor;
-	private static ComponentName component;
-	private static Button buttService;
-	private static TextView textview;
-	
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.managepage);
-		sqlAdapter = new SQLAdapter(this);
-		sqlAdapter.open();
-		sqlCursor = sqlAdapter.fetchAllLocations();
-		startManagingCursor(sqlCursor);
-		
-		Context pkg = getApplicationContext();
-		component = new ComponentName(pkg.getPackageName(), CustomReceiver.class.getName());
-		buttService = (Button) findViewById(R.id.buttservice);
-	  
-	}
-	  
-	public void fillData() {
-	
-		// Populate ListView from database
-		String[] from = new String[] {SQLAdapter.KEY_LABEL};
-		int[] to = new int[] {R.id.text1};
-	        
-		// Now create an array adapter and set it to display using our row
-		MyCursorAdapter labels = new MyCursorAdapter(this, R.layout.list_item, sqlCursor, from, to);
-		setListAdapter(labels);
-		
-		//Empower service button
-		Context pkg = getApplicationContext();
-		int io = pkg.getPackageManager().getComponentEnabledSetting(component);
-		int c = sqlCursor.getCount();
-		
-		if (c <= 0) {
-			buttService.setEnabled(false);
-			if (io == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
-				pkg.getPackageManager().setComponentEnabledSetting(component, PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
-				io = pkg.getPackageManager().getComponentEnabledSetting(component); }
-		} else if (c > 0) {
-			buttService.setEnabled(true);
-		}
-		
-		if (io == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
-			buttService.setText("Stop Service");
-		} else if ((io == PackageManager.COMPONENT_ENABLED_STATE_DISABLED) || (io == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT)) {
-			buttService.setText("Start Service");
-		}
-	     
-	}
-	
-	@Override
-    protected void onListItemClick(ListView l, View v, int position, long id) {
-        super.onListItemClick(l, v, position, id);
-        Cursor c = sqlCursor;
-        c.moveToPosition(position);
-        Intent i = new Intent(this, MapFrameActivity.class);
-        i.putExtra(SQLAdapter.KEY_ROWID, id);
-        i.putExtra(SQLAdapter.KEY_LABEL, c.getString(
-                c.getColumnIndexOrThrow(SQLAdapter.KEY_LABEL)));
-        i.putExtra(SQLAdapter.KEY_LATITUDE, c.getDouble(
-                c.getColumnIndexOrThrow(SQLAdapter.KEY_LATITUDE)));
-        i.putExtra(SQLAdapter.KEY_LONGITUDE, c.getDouble(
-                c.getColumnIndexOrThrow(SQLAdapter.KEY_LONGITUDE)));
-        i.putExtra(SQLAdapter.KEY_STATUS, c.getInt(
-                c.getColumnIndexOrThrow(SQLAdapter.KEY_STATUS)));
-        startActivity(i);
-    }
-	
-	private class MyCursorAdapter extends SimpleCursorAdapter {
-
-        public MyCursorAdapter(Context context, int layoutId, Cursor cur, String[] from, int[] to) {
-            super(context, layoutId, cur, from, to);
-        }
-
-        @Override
-        public void bindView(View view, Context context, Cursor cur) {
-            CheckedTextView checkTv = (CheckedTextView) view;
-            checkTv.setText(cur.getString(cur.getColumnIndex(SQLAdapter.KEY_LABEL)));
-            checkTv.setChecked((cur.getInt(cur.getColumnIndex(SQLAdapter.KEY_STATUS)))!=0);
-        }
-    }
-	
-	public void serviceClick(View view) {
-		Context pkg = getApplicationContext();
-		int io = pkg.getPackageManager().getComponentEnabledSetting(component);
-		textview = (TextView) getParent().findViewById(R.id.servicestatus);
-		if (io == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
-			pkg.getPackageManager().setComponentEnabledSetting(component, PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
-			buttService.setText("Start Service");
-			textview.setText("Service OFF");
-			textview.setTextColor(0x99FF3333);
-		} else if ((io == PackageManager.COMPONENT_ENABLED_STATE_DISABLED) || (io == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT)) {
-			pkg.getPackageManager().setComponentEnabledSetting(component, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP);
-			buttService.setText("Stop Service");
-			textview.setText("Service ON");
-			textview.setTextColor(0x9933FF33);
-		}
-	}
-	
-	@Override
-	protected void onPause() {
-		if (isFinishing())
-			sqlAdapter.close();
-		super.onPause();
-	}
-	@Override
-	protected void onResume() {
-		super.onResume();
-		fillData();
-	}
-	@Override
-	protected void onDestroy() {
-		sqlAdapter.close();
-		super.onDestroy();
-	}
-}
\ No newline at end of file
Index: src/com/groza/wifiauto/ManualActivity.java
===================================================================
--- src/com/groza/wifiauto/ManualActivity.java	(revision 13)
+++ src/com/groza/wifiauto/ManualActivity.java	(working copy)
@@ -1,173 +0,0 @@
-package com.groza.wifiauto;
-
-import java.io.IOException;
-import java.util.List;
-import java.util.Locale;
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.content.ContentResolver;
-import android.content.Intent;
-import android.database.Cursor;
-import android.location.Address;
-import android.location.Geocoder;
-import android.net.Uri;
-import android.os.Bundle;
-import android.provider.ContactsContract;
-import android.provider.ContactsContract.Contacts;
-import android.util.Log;
-import android.view.View;
-import android.view.inputmethod.InputMethodManager;
-import android.widget.EditText;
-import android.widget.TabHost;
-
-public class ManualActivity extends Activity {
-	//Class variables
-	private static String streetvalue, cityvalue, statevalue, zipvalue, address;
-	private static EditText streetfield, cityfield, statefield, zipfield;
-	private static double coordLat;
-	private static double coordLong;
-	private AlertDialog.Builder alert;
-	private static final int CONTACT_PICKER_RESULT = 1020, MAP_RESULT=1040;
-	private static InputMethodManager imm;
-		
-	//Manual acquisition of latitude and longitude.
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.manualpage);
-		streetfield = (EditText) findViewById(R.id.streetbox);
-		cityfield = (EditText) findViewById(R.id.citybox);
-		statefield = (EditText) findViewById(R.id.statebox);
-		zipfield = (EditText) findViewById(R.id.zipbox);
-		imm = (InputMethodManager) this.getSystemService(INPUT_METHOD_SERVICE);
-	}
-	
-	//Import Street, City, State, and Zip from contacts.
-	public void importContactInfo(View view) {
-		clearFields();
-		Intent contactPickerIntent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);
-		startActivityForResult(contactPickerIntent, CONTACT_PICKER_RESULT);
-	}
-	
-	public void verify(View view) {
-		
-		streetvalue = streetfield.getText().toString();
-		cityvalue = cityfield.getText().toString();
-		statevalue = statefield.getText().toString();
-		zipvalue = zipfield.getText().toString();
-		alert = new AlertDialog.Builder(ManualActivity.this).setTitle("Incomplete").setMessage("Street with City/State or Zip required.").setNeutralButton("Close", null);
-		
-		if ((!streetvalue.contentEquals("")) && ((!zipvalue.contentEquals("")) || ( (!cityvalue.contentEquals("") ) && (!statevalue.contentEquals("") )))) {
-			addressLookup(); } else {alert.show(); }
-	}
-	
-	public void addressLookup() {
-
-		alert = new AlertDialog.Builder(ManualActivity.this).setTitle("Address Not Found").setMessage("Please use Automatic Tab.").setNeutralButton("Close", null);
-		
-		if (!zipvalue.contentEquals("")) {
-			address = streetvalue + ", " + zipvalue;} else {
-			address = streetvalue + ", " + cityvalue + ", " + statevalue; }
-		
-		Geocoder geodex = new Geocoder(getApplicationContext(), Locale.US);
-		try {
-			List<Address> coordlist = geodex.getFromLocationName(address, 1);
-			if (coordlist != null) {
-				coordLat = coordlist.get(0).getLatitude();
-				coordLong = coordlist.get(0).getLongitude();
-				Intent mapIntent = new Intent(ManualActivity.this, MapFrameActivity.class);
-				mapIntent.putExtra("latitude", coordLat);
-				mapIntent.putExtra("longitude", coordLong);
-				startActivityForResult(mapIntent, MAP_RESULT);
-			} else {
-				alert.show();
-			}
-		} catch (IOException e) {
-			new AlertDialog.Builder(ManualActivity.this).setTitle("Maps Not Found").setMessage("Install Google Maps or use Automatic Tab.").setNeutralButton("Close", null).show();
-			Log.e("IOException", e.getMessage());
-		}
-	}
-	
-	public void clearFields() {
-		EditText[] locFields = {streetfield, cityfield, statefield, zipfield};
-		for (int i = 0; i < locFields.length; i++) {
-			locFields[i].setText("");
-		}
-		streetvalue = cityvalue = statevalue = zipvalue = "";
-	}
-	
-	@Override
-	public void onActivityResult(int requestCode, int resultCode, Intent intent) {
-		if (resultCode == RESULT_OK) {
-			switch (requestCode) {
-			case CONTACT_PICKER_RESULT:
-				try {
-					//attempt fetch of address
-					Cursor addrCur = null;
-					Uri contactUri = intent.getData();
-					String contactId = contactUri.getLastPathSegment();
-					ContentResolver cr = getContentResolver();
-					String addrWhere = ContactsContract.Data.CONTACT_ID + " = ? AND " + ContactsContract.Data.MIMETYPE + " = ?"; 
-					String[] addrWhereParams = new String[]{contactId, ContactsContract.CommonDataKinds.StructuredPostal.CONTENT_ITEM_TYPE}; 
-					addrCur = cr.query(ContactsContract.Data.CONTENT_URI, null, addrWhere, addrWhereParams, null); 
-					if (addrCur.moveToNext()) {
-						streetvalue = addrCur.getString(
-							addrCur.getColumnIndex(ContactsContract.CommonDataKinds.StructuredPostal.STREET));
-						cityvalue = addrCur.getString(
-							addrCur.getColumnIndex(ContactsContract.CommonDataKinds.StructuredPostal.CITY));
-						statevalue = addrCur.getString(
-							addrCur.getColumnIndex(ContactsContract.CommonDataKinds.StructuredPostal.REGION));
-						zipvalue = addrCur.getString(
-							addrCur.getColumnIndex(ContactsContract.CommonDataKinds.StructuredPostal.POSTCODE));
-					} else {
-						Log.w("DEBUG", "No results found");
-						streetvalue = cityvalue = statevalue = zipvalue = "";
-					}
-					if (addrCur != null)
-						addrCur.close();
-				} catch (Exception e) {
-					//report a failed lookup
-					alert = new AlertDialog.Builder(ManualActivity.this).setTitle("Error").setMessage("Contact address lookup failed.").setNeutralButton("Close", null);
-					alert.show();
-					Log.e("DEBUG", "Failed to fetch address", e);
-				} finally {
-					//check for and assign retrieved values
-					EditText[] locFields = {streetfield, cityfield, statefield, zipfield};
-					String[] locValues = {streetvalue, cityvalue, statevalue, zipvalue};
-					int i, j = 0;
-					for (i = 0; i < locValues.length; i++) {
-						if (locValues[i] == null)
-							locValues[i] = "";
-						boolean isField = locValues[i].length() != 0;
-						locFields[i].setText(isField ? locValues[i] : "");
-						if (isField)
-							j++;
-					}
-					if (j == 0) {
-						alert = new AlertDialog.Builder(ManualActivity.this).setTitle("Empty").setMessage("Contact returned no address.").setNeutralButton("Close", null);
-						alert.show();
-					}
-				}
-				break;
-			case MAP_RESULT:
-				clearFields();
-				TabHost tabHost =  (TabHost) getParent().findViewById(android.R.id.tabhost);
-	            tabHost.setCurrentTab(2);
-				break;
-			default:
-				Log.w("DEBUG", "Activity not prepared to handle request");
-				break;
-			}
-		} else {
-			Log.w("DEBUG", "Activity result not OK");
-		}
-	}
-	
-	@Override
-	public void onResume() {
-		super.onResume();
-		imm.hideSoftInputFromWindow(streetfield.getWindowToken(), 0);
-		imm.hideSoftInputFromWindow(zipfield.getWindowToken(), 0);
-	}
-
-}
\ No newline at end of file
Index: src/com/groza/wifiauto/MapFrameActivity.java
===================================================================
--- src/com/groza/wifiauto/MapFrameActivity.java	(revision 13)
+++ src/com/groza/wifiauto/MapFrameActivity.java	(working copy)
@@ -1,190 +0,0 @@
-package com.groza.wifiauto;
-
-import java.util.List;
-
-import android.app.AlertDialog;
-import android.content.DialogInterface;
-import android.graphics.drawable.Drawable;
-import android.os.Bundle;
-import android.view.View;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.TextView;
-
-import com.google.android.maps.GeoPoint;
-import com.google.android.maps.MapActivity;
-import com.google.android.maps.MapController;
-import com.google.android.maps.MapView;
-import com.google.android.maps.Overlay;
-import com.google.android.maps.OverlayItem;
-
-public class MapFrameActivity extends MapActivity {
-	private static double lat;
-	private static double lon;
-	private static int i;
-	private static Button b;
-	private static TextView tv;
-	private AlertDialog.Builder alert;
-	private SQLAdapter sqlAdapter;
-	
-	@Override
-	protected boolean isRouteDisplayed() {
-		return false;
-	}
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		if (getIntent().hasExtra(SQLAdapter.KEY_LABEL)) {
-			setContentView(R.layout.editdialog);
-			format();}
-		else {setContentView(R.layout.mapdialog); }
-		
-		MapView mapbox = (MapView) findViewById(R.id.mapbox);
-		mapbox.setBuiltInZoomControls(true);
-		
-		List<Overlay> mapOverlays = mapbox.getOverlays();
-		Drawable drawable = this.getResources().getDrawable(android.R.drawable.ic_notification_overlay);
-		MapOverlayActivity overlayMarker = new MapOverlayActivity(drawable);
-		
-		lat = getIntent().getDoubleExtra(SQLAdapter.KEY_LATITUDE, 0);
-		lon = getIntent().getDoubleExtra(SQLAdapter.KEY_LONGITUDE, 0);
-		
-		GeoPoint point = new GeoPoint((int)(lat*1E6), (int)(lon*1E6));
-		OverlayItem markPoint = new OverlayItem(point, "", "");
-		
-		overlayMarker.addOverlay(markPoint);
-		mapOverlays.add(overlayMarker);
-		
-		MapController mcontrol = mapbox.getController();
-		mcontrol.animateTo(point);
-		mcontrol.setZoom(18);
-		
-		sqlAdapter = new SQLAdapter(this);
-		sqlAdapter.open();
-		
-	}
-	
-	public void format() {
-		i = getIntent().getIntExtra("status", 1);
-		buttSwitch();
-		
-		tv = (TextView) findViewById(R.id.showlabel);
-		String s = "Name: " + getIntent().getStringExtra("label");
-		tv.setText(s);
-		tv = (TextView) findViewById(R.id.showlat);
-		double d = getIntent().getDoubleExtra("latitude", 0);
-		s = "Latitude: " + Double.toString(d);
-		tv.setText(s);
-		tv = (TextView) findViewById(R.id.showlon);
-		d = getIntent().getDoubleExtra("longitude", 0);
-		s = "Longitude: " + Double.toString(d);
-		tv.setText(s);
-	}
-	
-	public void buttSwitch() {
-		tv = (TextView) findViewById(R.id.showstatus);
-		b = (Button) findViewById(R.id.buttstatus);
-		if (i == 0) {
-			b.setText(getString(R.string.button_enable));
-			tv.setText("Status: Disabled"); }
-		else {b.setText(getString(R.string.button_disable));
-			tv.setText("Status: Enabled"); }
-	}
-	
-	public void yesClick(View view) {
-		alert = new AlertDialog.Builder(MapFrameActivity.this);
-		alert.setTitle("Success").setMessage("Enter a name for this location.");
-
-		final EditText input = new EditText(MapFrameActivity.this);
-		alert.setView(input);
-
-		alert.setPositiveButton("Ok", new DialogInterface.OnClickListener() {
-		public void onClick(DialogInterface dialog, int whichButton) {
-			String name = input.getText().toString();
-			sqlAdapter.createLocation(name, lat, lon, 1);
-			terminate();
-		  }
-		});
-
-		alert.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
-		  public void onClick(DialogInterface dialog, int whichButton) {
-			  terminate();
-		  }
-		});
-
-		alert.show();
-	}
-	
-	public void noClick(View view) {
-		alert = new AlertDialog.Builder(MapFrameActivity.this);
-		alert.setTitle("Sorry").setMessage("Please try again or use alternate method.");
-		alert.setNeutralButton("Close", new DialogInterface.OnClickListener() {
-			public void onClick(DialogInterface dialog, int id) {
-				finish(); }});
-		alert.show();
-	}
-	
-	public void editClick(View view) {
-		alert = new AlertDialog.Builder(MapFrameActivity.this);
-		alert.setTitle("Rename").setMessage("Enter a new name for this location.");
-
-		final EditText input = new EditText(MapFrameActivity.this);
-		alert.setView(input);
-
-		alert.setPositiveButton("Ok", new DialogInterface.OnClickListener() {
-		public void onClick(DialogInterface dialog, int whichButton) {
-			long locId = getIntent().getLongExtra(SQLAdapter.KEY_ROWID, 0);
-			String name = input.getText().toString();
-			sqlAdapter.updateLocation(locId, name, lat, lon, 1);
-			terminate();
-		  }
-		});
-
-		alert.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
-		  public void onClick(DialogInterface dialog, int whichButton) {
-			  terminate();
-		  }
-		});
-
-		alert.show();
-	}
-	
-	public void statusClick(View view) {
-		long locId = getIntent().getLongExtra(SQLAdapter.KEY_ROWID, 0);
-		String name = getIntent().getStringExtra(SQLAdapter.KEY_LABEL);
-		if (i == 0) {
-			sqlAdapter.updateLocation(locId, name, lat, lon, 1);
-			i = 1; }
-		else {
-			sqlAdapter.updateLocation(locId, name, lat, lon, 0);
-			i = 0; }
-		buttSwitch();
-	}
-	
-	public void deleteClick(View view) {
-		long locId = getIntent().getLongExtra(SQLAdapter.KEY_ROWID, 0);
-		sqlAdapter.deleteLocation(locId);
-		terminate();
-	}
-	
-	public void closeClick(View view) {
-		terminate();
-	}
-	
-	public void terminate() {
-		setResult(RESULT_OK);
-		finish();
-	}
-	
-	@Override
-	protected void onPause() {
-		super.onPause();
-		if (isFinishing())
-			sqlAdapter.close();
-	}
-	@Override
-	protected void onDestroy() {
-		sqlAdapter.close();
-		super.onDestroy();
-	}
-}
Index: src/com/groza/wifiauto/MapOverlayActivity.java
===================================================================
--- src/com/groza/wifiauto/MapOverlayActivity.java	(revision 3)
+++ src/com/groza/wifiauto/MapOverlayActivity.java	(working copy)
@@ -1,32 +0,0 @@
-package com.groza.wifiauto;
-
-import java.util.ArrayList;
-
-import android.graphics.drawable.Drawable;
-
-import com.google.android.maps.ItemizedOverlay;
-import com.google.android.maps.OverlayItem;
-
-public class MapOverlayActivity extends ItemizedOverlay<OverlayItem> {
-	
-	private ArrayList<OverlayItem> mapoverlay = new ArrayList<OverlayItem>();
-	
-	public MapOverlayActivity(Drawable defaultMarker) {
-		super(boundCenterBottom(defaultMarker));
-	}
-	
-	public void addOverlay(OverlayItem overlay) {
-	    mapoverlay.add(overlay);
-	    populate();
-	}
-	
-	@Override
-	protected OverlayItem createItem(int i) {
-		return mapoverlay.get(i);
-	}
-	
-	@Override
-	public int size() {
-		return mapoverlay.size();
-	}
-}
Index: src/com/groza/wifiauto/ProximityMachine.java
===================================================================
--- src/com/groza/wifiauto/ProximityMachine.java	(revision 14)
+++ src/com/groza/wifiauto/ProximityMachine.java	(working copy)
@@ -1,249 +0,0 @@
-package com.groza.wifiauto;
-
-import android.app.Service;
-import android.content.Intent;
-import android.database.Cursor;
-import android.location.Location;
-import android.location.LocationListener;
-import android.location.LocationManager;
-import android.location.LocationProvider;
-import android.net.ConnectivityManager;
-import android.net.NetworkInfo;
-import android.net.wifi.WifiManager;
-import android.os.Bundle;
-import android.os.CountDownTimer;
-import android.os.IBinder;
-import android.telephony.TelephonyManager;
-
-public class ProximityMachine extends Service {
-	private static LocationManager locationManager;
-	private static WifiManager wifiManager;
-	private static TelephonyManager teleManager;
-	private static Location finalLocation;
-	private static LocationListener locationListener;
-	private static final int TWO_MINUTES = 120000;
-	private static final int MODE_NETWORK = 1, MODE_GPS = 2, PRELIMINARY = 1, FINAL = 2;
-	private static final int MODE_ALL = MODE_NETWORK | MODE_GPS;
-	private static final int PRELIM_DELTA = 800;
-	private static final long ONE_SECOND = 1000;
-	private static int c, tick, callStatus, whichRound;
-	private static boolean wifiEnabled, gpsEnabled, wifiConnected, cellAvailable, ticktock;
-	private SQLAdapter sqlAdapter;
-	private Cursor sqlCursor;
-	public static int setFinalDelta = 80;
-	public static int setTimeout = 25;
-	
-	private CountDownTimer timeout = new CountDownTimer(ONE_SECOND*setTimeout, ONE_SECOND) {
-	     public void onTick(long remainder) {}
-
-	     public void onFinish() {
-	    	endListener();
-	    	ticktock = false;
-	    	if (finalLocation != null) {
-				process(finalLocation);
-	    	} else {
-				stopSelf();
-			}
-	     }
-	  };
-	
-	@Override
-	public IBinder onBind(Intent intent) {
-		return null;
-	}
-	
-	@Override
-	public void onCreate() {
-		
-		wifiManager = (WifiManager) this.getSystemService(WIFI_SERVICE);
-		locationManager = (LocationManager) this.getSystemService(LOCATION_SERVICE);
-		teleManager = (TelephonyManager) this.getSystemService(TELEPHONY_SERVICE);
-		ConnectivityManager conManager = (ConnectivityManager) this.getSystemService(CONNECTIVITY_SERVICE);
-		NetworkInfo wifiCon = conManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
-		NetworkInfo cellCon = conManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
-		
-		finalLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
-		
-		gpsEnabled = (locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER));
-		wifiEnabled = (wifiManager.isWifiEnabled());
-		wifiConnected = wifiCon.isConnected();
-		cellAvailable = cellCon.isAvailable();
-		callStatus = teleManager.getCallState();
-		ticktock = false;
-		
-		sqlAdapter = new SQLAdapter(this);
-		sqlAdapter.open();
-		sqlCursor = sqlAdapter.fetchAllLocations();    	
-	}
-	
-	@Override
-	public int onStartCommand(Intent intent, int flags, int id) {
-		
-		switch(callStatus) {
-		case TelephonyManager.CALL_STATE_OFFHOOK:
-		case TelephonyManager.CALL_STATE_RINGING:
-			stopSelf();
-			break;
-		case TelephonyManager.CALL_STATE_IDLE:
-		default:
-			break;
-		}
-		
-		c = sqlCursor.getCount();
-		
-		if ( (c <= 0) || (wifiConnected) || (!gpsEnabled && !wifiEnabled && !cellAvailable) ) {
-			stopSelf();
-			return START_NOT_STICKY;
-		}
-		
-		locationListener = new LocationListener() {
-    		public void onLocationChanged(Location location) {
-    			if (isBetterLocation(location, finalLocation)) {
-    	    		finalLocation = location; }
-    			tick++;
-    			if (tick >= whichRound) {
-    				timeout.cancel();
-    				endListener();
-    				ticktock = false;
-    				process(finalLocation);
-    			}
-    		}
-    		public void onStatusChanged(String provider, int status, Bundle extras) {
-    			if (status == LocationProvider.OUT_OF_SERVICE)
-    				stopSelf();
-    		}
-    		public void onProviderEnabled(String provider) {}
-    		public void onProviderDisabled(String provider) {
-    			stopSelf();
-    		}
-    	};
-    	
-    	if (gpsEnabled) {
-    		if (wifiEnabled || cellAvailable) {
-    			findLocation(MODE_NETWORK, PRELIMINARY);
-    		} else {
-    			findLocation(MODE_GPS, FINAL);
-    		}
-    	} else {
-    		if (wifiEnabled || cellAvailable) {
-    			findLocation(MODE_NETWORK, FINAL);
-    		} else {
-    			stopSelf();
-    		}
-    	}
-    		
-    	return START_NOT_STICKY;
-	}
-	
-	private void findLocation(int mode, int round) {		
-		whichRound = round;
-    	tick = 0;
-    	ticktock = true;
-		
-		if ((mode & MODE_NETWORK) > 0)
-			locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0, locationListener);
-    	if ((mode & MODE_GPS) > 0)
-    		locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);
-    	
-    	timeout.start();
-	}
-	
-	private void process(Location currentLocation) {
-		
-		int io = 0;
-		int processDelta = whichRound > 1 ? setFinalDelta : PRELIM_DELTA;
-		
-		for (int i = 0; i < c; i++) {
-			sqlCursor.moveToPosition(i);
-			int s = sqlCursor.getInt(sqlCursor.getColumnIndexOrThrow(SQLAdapter.KEY_STATUS));
-			if (s == 1) {
-				Location storedLocation = new Location("");
-				storedLocation.setLatitude(sqlCursor.getDouble(sqlCursor.getColumnIndexOrThrow(SQLAdapter.KEY_LATITUDE)));
-				storedLocation.setLongitude(sqlCursor.getDouble(sqlCursor.getColumnIndexOrThrow(SQLAdapter.KEY_LONGITUDE)));
-				float delta = storedLocation.distanceTo(currentLocation);
-				if (delta <= processDelta)
-					io++;
-			}
-		}
-		
-		if (io == 0) {
-			wifiManager.setWifiEnabled(false);
-			stopSelf();
-		} else if (io * whichRound > io) {
-			wifiManager.setWifiEnabled(true);
-			stopSelf();
-		} else
-			findLocation(MODE_ALL, FINAL);				
-	}
-	
-	private boolean isBetterLocation(Location location, Location currentBestLocation) {
-        if (currentBestLocation == null) {
-            // A new location is always better than no location
-            return true;
-        }
-
-        // Check whether the new location fix is newer or older
-        long timeDelta = location.getTime() - currentBestLocation.getTime();
-        boolean isSignificantlyNewer = timeDelta > TWO_MINUTES;
-        boolean isSignificantlyOlder = timeDelta < -TWO_MINUTES;
-        boolean isNewer = timeDelta > 0;
-
-        // If it's been more than two minutes since the current location, use the new location
-        // because the user has likely moved
-        if (isSignificantlyNewer) {
-            return true;
-        // If the new location is more than two minutes older, it must be worse
-        } else if (isSignificantlyOlder) {
-            return false;
-        }
-
-        // Check whether the new location fix is more or less accurate
-        int accuracyDelta = (int) (location.getAccuracy() - currentBestLocation.getAccuracy());
-        boolean isLessAccurate = accuracyDelta > 0;
-        boolean isMoreAccurate = accuracyDelta < 0;
-        boolean isSignificantlyLessAccurate = accuracyDelta > 200;
-
-        // Check if the old and new location are from the same provider
-        boolean isFromSameProvider = isSameProvider(location.getProvider(),
-                currentBestLocation.getProvider());
-
-        // Determine location quality using a combination of timeliness and accuracy
-        if (isMoreAccurate) {
-            return true;
-        } else if (isNewer && !isLessAccurate) {
-            return true;
-        } else if (isNewer && !isSignificantlyLessAccurate && isFromSameProvider) {
-            return true;
-        }
-        return false;
-    }
-
-    /** Checks whether two providers are the same */
-    private boolean isSameProvider(String provider1, String provider2) {
-        if (provider1 == null) {
-          return provider2 == null;
-        }
-        return provider1.equals(provider2);
-    }
-    
-    private void endListener() {
-    	locationManager.removeUpdates(locationListener);
-    	ticktock = false;
-		tick = 0;
-    }
-        
-    private void terminate() {
-    	sqlCursor.close();
-    	sqlAdapter.close();
-    	if (ticktock) {
-    		timeout.cancel();
-    		endListener();
-    	}
-    }
-    
-    @Override
-    public void onDestroy() {
-    	terminate();
-    }
-
-}
Index: src/com/groza/wifiauto/SQLAdapter.java
===================================================================
--- src/com/groza/wifiauto/SQLAdapter.java	(revision 3)
+++ src/com/groza/wifiauto/SQLAdapter.java	(working copy)
@@ -1,114 +0,0 @@
-package com.groza.wifiauto;
-
-import android.content.ContentValues;
-import android.content.Context;
-import android.database.Cursor;
-import android.database.SQLException;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.util.Log;
-
-public class SQLAdapter {
-	
-	public final static String KEY_LABEL = "label";
-    public final static String KEY_LATITUDE = "latitude";
-    public final static String KEY_LONGITUDE = "longitude";
-    public final static String KEY_STATUS = "status";
-    public final static String KEY_ROWID = "_id";
-
-    private static final String TAG = "rainbowSQLAdapter";
-    private SQLSetup dbSetup;
-    private SQLiteDatabase sqlDb;
-	
-    private final Context dbContext;
-	
-	private static final String DATABASE_NAME = "PointsOfDesire";
-	private static final String DATABASE_TABLE = "rainbow";
-	private static final int DATABASE_VERSION = 1;
-	private static final String DATABASE_CREATE =
-			"create table rainbow (_id integer primary key autoincrement, "
-			+ "label text not null, latitude real not null, "
-			+ "longitude real not null, status integer not null);";
-	
-	private static class SQLSetup extends SQLiteOpenHelper {
-		
-		public SQLSetup(Context context) {
-			super(context, DATABASE_NAME, null, DATABASE_VERSION);
-			
-		}
-
-		@Override
-		public void onCreate(SQLiteDatabase db) {
-			db.execSQL(DATABASE_CREATE);
-
-		}
-
-		@Override
-		public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-			Log.w(TAG, "Upgrading database from version " + oldVersion + " to "
-                    + newVersion + ", which will destroy all old data");
-            db.execSQL("DROP TABLE IF EXISTS rainbow");
-            onCreate(db);
-
-		}
-	}
-	
-	public SQLAdapter(Context context) {
-		this.dbContext = context;
-	}
-	
-	public SQLAdapter open() throws SQLException {
-		dbSetup = new SQLSetup(dbContext);
-		sqlDb = dbSetup.getWritableDatabase();
-		return this;
-	}
-	
-	public void close() {
-		dbSetup.close();
-	}
-	
-	public long createLocation(String label, double latitude, double longitude, int status) {
-	    ContentValues initialValues = new ContentValues();
-	    initialValues.put(KEY_LABEL, label);
-	    initialValues.put(KEY_LATITUDE, latitude);
-	    initialValues.put(KEY_LONGITUDE, longitude);
-	    initialValues.put(KEY_STATUS, status);
-
-        return sqlDb.insert(DATABASE_TABLE, null, initialValues);
-    }
-	
-	public boolean deleteLocation(long rowId) {
-
-        return sqlDb.delete(DATABASE_TABLE, KEY_ROWID + "=" + rowId, null) > 0;
-    }
-	
-	public Cursor fetchAllLocations() {
-
-        return sqlDb.query(DATABASE_TABLE, new String[] {KEY_ROWID, KEY_LABEL, KEY_LATITUDE, KEY_LONGITUDE, KEY_STATUS}, null, null, null, null, null);
-    }
-	
-	public Cursor fetchLocation(long rowId) throws SQLException {
-
-        Cursor mCursor =
-
-            sqlDb.query(true, DATABASE_TABLE, new String[] {KEY_ROWID,
-                    KEY_LABEL, KEY_LATITUDE, KEY_LONGITUDE, KEY_STATUS}, KEY_ROWID + "=" + rowId, null,
-                    null, null, null, null);
-        if (mCursor != null) {
-            mCursor.moveToFirst();
-        }
-        return mCursor;
-
-    }
-	
-	public boolean updateLocation(long rowId, String label, double latitude, double longitude, int status) {
-        ContentValues args = new ContentValues();
-        args.put(KEY_LABEL, label);
-        args.put(KEY_LATITUDE, latitude);
-        args.put(KEY_LONGITUDE, longitude);
-        args.put(KEY_STATUS, status);
-
-        return sqlDb.update(DATABASE_TABLE, args, KEY_ROWID + "=" + rowId, null) > 0;
-    }
-
-}
Index: src/com/groza/wifiauto/WifiAutoToggleActivity.java
===================================================================
--- src/com/groza/wifiauto/WifiAutoToggleActivity.java	(revision 13)
+++ src/com/groza/wifiauto/WifiAutoToggleActivity.java	(working copy)
@@ -1,146 +0,0 @@
-package com.groza.wifiauto;
-
-import java.util.List;
-
-import android.app.AlertDialog;
-import android.app.TabActivity;
-import android.content.ActivityNotFoundException;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.content.res.Resources;
-import android.location.LocationManager;
-import android.net.wifi.WifiManager;
-import android.os.Bundle;
-import android.provider.Settings;
-import android.util.Log;
-import android.view.View;
-import android.widget.TabHost;
-import android.widget.TextView;
-
-public class WifiAutoToggleActivity extends TabActivity {
-    /** Called when the activity is first created. */
-	
-	//Anchor Wifi and GPS service connections.
-	public static WifiManager wifiManager;
-    public static LocationManager locationManager;
-    private static TextView textview;
-    private static ComponentName component;
-	
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main);
-
-        Resources res = getResources(); // Resource object to get Drawables
-        TabHost tabHost = getTabHost();  // The activity TabHost
-        TabHost.TabSpec spec;  // Reusable TabSpec for each tab
-        Intent intent;  // Reusable Intent for each tab
-
-        // Create an Intent to launch an Activity for the tab (to be reused)
-        intent = new Intent().setClass(this, AutomaticActivity.class);
-
-        // Initialize a TabSpec for each tab and add it to the TabHost
-        spec = tabHost.newTabSpec("automatic").setIndicator("Automatic",
-                res.getDrawable(R.drawable.ic_tab_auto))
-                      .setContent(intent);
-        tabHost.addTab(spec);
-
-        // Do the same for the other tabs
-        intent = new Intent().setClass(this, ManualActivity.class);
-        spec = tabHost.newTabSpec("manual").setIndicator("Manual",
-                res.getDrawable(R.drawable.ic_tab_manual))
-                      .setContent(intent);
-        tabHost.addTab(spec);
-
-        intent = new Intent().setClass(this, ManageActivity.class);
-        spec = tabHost.newTabSpec("manage").setIndicator("Manage",
-                res.getDrawable(R.drawable.ic_tab_manage))
-                      .setContent(intent);
-        tabHost.addTab(spec);
-
-       	tabHost.setCurrentTab(0);
-       	
-       	Context pkg = getApplicationContext();
-		component = new ComponentName(pkg.getPackageName(), CustomReceiver.class.getName());
-       	
-       	wifiManager = (WifiManager) this.getSystemService(Context.WIFI_SERVICE);
-		locationManager = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE);
-        
-    }
-    
-    public void serviceStatus() {
-		textview = (TextView) findViewById(R.id.GPSstatus);		
-		if (locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {
-        	textview.setText("GPS ON");
-        	textview.setTextColor(0x9933FF33);
-        } else {
-        	textview.setText("GPS OFF");
-        	textview.setTextColor(0x99FF3333);
-        }
-        textview = (TextView) findViewById(R.id.WIFIstatus);
-        if (wifiManager.isWifiEnabled()) {
-        	textview.setText("WiFi ON");
-        	textview.setTextColor(0x9933FF33);
-        } else {
-        	textview.setText("WiFi OFF");
-        	textview.setTextColor(0x99FF3333);
-        }
-        textview = (TextView) findViewById(R.id.servicestatus);
-        Context pkg = getApplicationContext();
-		int io = pkg.getPackageManager().getComponentEnabledSetting(component);
-		if (io == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
-			textview.setText("Service ON");
-			textview.setTextColor(0x9933FF33);
-		} else if ((io == PackageManager.COMPONENT_ENABLED_STATE_DISABLED) || (io == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT)) {
-			textview.setText("Service OFF");
-			textview.setTextColor(0x99FF3333);
-		}
-        
-    }
-    
-  //TextView-click method to launch settings menu
-  	public void changeSettings(View view) {
-  		//Catch-all menu for all devices
-  		Intent settingsIntent = new Intent(Settings.ACTION_WIRELESS_SETTINGS);
-  		Intent tmpIntent;
-  		
-  		//Assign specifically requested menu for devices that have them 
-  		switch (view.getId()) {
-  		case R.id.GPSstatus:
-  			tmpIntent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS);
-  			if (isCallable(tmpIntent))
-  				settingsIntent = tmpIntent;
-  			break;
-  		case R.id.WIFIstatus:
-  			tmpIntent = new Intent(Settings.ACTION_WIFI_SETTINGS);
-  			if (isCallable(tmpIntent))
-  				settingsIntent = tmpIntent;
-  			break;
-  		default:			
-  			break;
-  		}
-  		
-  		//Launch menu
-  		try {
-  			startActivity(settingsIntent);
-  		} catch (ActivityNotFoundException e) {
-  			new AlertDialog.Builder(WifiAutoToggleActivity.this).setTitle("Menu Not Found").setMessage("Could not launch chosen Settings menu.").setNeutralButton("Close", null).show();
-  			Log.e("DEBUG", e.getMessage());
-  		}
-  	}
-  	
-  	private boolean isCallable(Intent intent) {
-        List<ResolveInfo> list = getPackageManager().queryIntentActivities(intent, 
-            PackageManager.MATCH_DEFAULT_ONLY);
-        return list.size() > 0;
-  	}
-    
-    @Override
-    public void onResume() {
-    	super.onResume();
-    	serviceStatus();
-    }
-}
\ No newline at end of file
Index: src/com/nolnoch/wifiauto/AutomaticActivity.java
===================================================================
--- src/com/nolnoch/wifiauto/AutomaticActivity.java	(revision 0)
+++ src/com/nolnoch/wifiauto/AutomaticActivity.java	(working copy)
@@ -0,0 +1,188 @@
+package com.nolnoch.wifiauto;
+
+import android.app.Activity;
+import android.app.ProgressDialog;
+import android.content.Context;
+import android.content.Intent;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.net.wifi.WifiManager;
+import android.os.Bundle;
+import android.os.CountDownTimer;
+import android.util.Log;
+import android.view.View;
+import android.widget.TabHost;
+import android.widget.Toast;
+
+public class AutomaticActivity extends Activity {
+	//Anchor Wifi and GPS service connections.
+	public static WifiManager wifiManager;
+	public static LocationManager locationManager;
+    
+    public static Location finalLocation;
+    public static LocationListener locationListener; 
+	public static int tick = 0;
+	private static final int TWO_MINUTES = 120000;
+	private static final int AUTO_RESULT = 1060;
+	private static final long ONE_SECOND = 1000;
+	private static double coordLat;
+	private static double coordLong;
+	private static boolean ticktock = false;
+	
+	private static ProgressDialog searching;
+	
+	private CountDownTimer timeout = new CountDownTimer(ONE_SECOND*40, ONE_SECOND) {
+	     public void onTick(long remainder) {}
+
+	     public void onFinish() {
+	    	endListener();
+	    	ticktock = false;
+	    	if (finalLocation != null) {
+				process(); }
+			else {Toast.makeText(getApplicationContext(), "Network timeout. Please try again.", Toast.LENGTH_SHORT).show(); }
+	     }
+	  };
+	
+	public void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		setContentView(R.layout.autopage);
+        
+		wifiManager = (WifiManager) this.getSystemService(Context.WIFI_SERVICE);
+		locationManager = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE);
+        
+    	finalLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
+    	
+	}
+	
+	//Define method called by Button click.
+    public void locateMe(View view) {
+    	
+    	searching = ProgressDialog.show(AutomaticActivity.this, "", 
+                "Searching...", true, false);
+    	
+    	locationListener = new LocationListener() {
+    		public void onLocationChanged(Location location) {
+    			if (isBetterLocation(location, finalLocation)) {
+    	    		finalLocation = location; }
+    			tick++;
+    			if (tick >= 3) {
+    				timeout.cancel();
+    				endListener();
+    				if (finalLocation != null) {
+    					process(); }
+    				else {
+    					Toast.makeText(getApplicationContext(), "No location found.", Toast.LENGTH_SHORT).show(); }
+    			}
+    		}
+    		public void onStatusChanged(String provider, int status, Bundle extras) {}
+    		public void onProviderEnabled(String provider) {}
+    		public void onProviderDisabled(String provider) {}
+    	};
+    	    	
+    	locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0, locationListener);
+    	locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);
+    	  
+    	timeout.start();
+    	ticktock = true;
+    }
+    
+    /** Determines whether one Location reading is better than the current Location fix
+      * @param location  The new Location that you want to evaluate
+      * @param currentBestLocation  The current Location fix, to which you want to compare the new one
+      */
+    protected boolean isBetterLocation(Location location, Location currentBestLocation) {
+        if (currentBestLocation == null) {
+            // A new location is always better than no location
+            return true;
+        }
+
+        // Check whether the new location fix is newer or older
+        long timeDelta = location.getTime() - currentBestLocation.getTime();
+        boolean isSignificantlyNewer = timeDelta > TWO_MINUTES;
+        boolean isSignificantlyOlder = timeDelta < -TWO_MINUTES;
+        boolean isNewer = timeDelta > 0;
+
+        // If it's been more than two minutes since the current location, use the new location
+        // because the user has likely moved
+        if (isSignificantlyNewer) {
+            return true;
+        // If the new location is more than two minutes older, it must be worse
+        } else if (isSignificantlyOlder) {
+            return false;
+        }
+
+        // Check whether the new location fix is more or less accurate
+        int accuracyDelta = (int) (location.getAccuracy() - currentBestLocation.getAccuracy());
+        boolean isLessAccurate = accuracyDelta > 0;
+        boolean isMoreAccurate = accuracyDelta < 0;
+        boolean isSignificantlyLessAccurate = accuracyDelta > 200;
+
+        // Check if the old and new location are from the same provider
+        boolean isFromSameProvider = isSameProvider(location.getProvider(),
+                currentBestLocation.getProvider());
+
+        // Determine location quality using a combination of timeliness and accuracy
+        if (isMoreAccurate) {
+            return true;
+        } else if (isNewer && !isLessAccurate) {
+            return true;
+        } else if (isNewer && !isSignificantlyLessAccurate && isFromSameProvider) {
+            return true;
+        }
+        return false;
+    }
+
+    /** Checks whether two providers are the same */
+    private boolean isSameProvider(String provider1, String provider2) {
+        if (provider1 == null) {
+          return provider2 == null;
+        }
+        return provider1.equals(provider2);
+    }
+    
+    public void endListener() {
+    	locationManager.removeUpdates(locationListener);
+    	searching.dismiss();
+		tick = 0;
+    }
+    
+    public void process() {
+    	coordLat = finalLocation.getLatitude();
+		coordLong = finalLocation.getLongitude();
+		
+		Intent intent = new Intent(AutomaticActivity.this, MapFrameActivity.class);
+		intent.putExtra("latitude", coordLat);
+		intent.putExtra("longitude", coordLong);
+		startActivityForResult(intent, AUTO_RESULT);
+    }
+    
+    @Override
+	public void onActivityResult(int requestCode, int resultCode, Intent intent) {
+		if (resultCode == RESULT_OK) {
+			switch (requestCode) {
+			case AUTO_RESULT:
+				TabHost tabHost =  (TabHost) getParent().findViewById(android.R.id.tabhost);
+	            tabHost.setCurrentTab(2);
+				break;
+			default:
+				Log.w("DEBUG", "Activity not prepared to handle request");
+				break;
+			}
+		} else {
+			Log.w("DEBUG", "Activity result not OK");
+		}
+	}
+    
+    @Override
+	protected void onPause() {
+    	if (ticktock) {
+    		timeout.cancel();
+    		endListener(); }
+    	super.onPause();
+	}
+	@Override
+	protected void onResume() {
+		super.onResume();
+	}
+}
\ No newline at end of file
Index: src/com/nolnoch/wifiauto/AutomaticActivity.java
===================================================================
--- src/com/nolnoch/wifiauto/AutomaticActivity.java	(revision 13)
+++ src/com/nolnoch/wifiauto/AutomaticActivity.java	(working copy)

Property changes on: src/com/nolnoch/wifiauto/AutomaticActivity.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: src/com/nolnoch/wifiauto/CustomReceiver.java
===================================================================
--- src/com/nolnoch/wifiauto/CustomReceiver.java	(revision 0)
+++ src/com/nolnoch/wifiauto/CustomReceiver.java	(working copy)
@@ -0,0 +1,14 @@
+package com.nolnoch.wifiauto;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+
+public class CustomReceiver extends BroadcastReceiver {
+
+	@Override
+	public void onReceive(Context context, Intent intent) {
+		context.startService(new Intent(context, ProximityMachine.class));
+	}
+
+}
Index: src/com/nolnoch/wifiauto/CustomReceiver.java
===================================================================
--- src/com/nolnoch/wifiauto/CustomReceiver.java	(revision 3)
+++ src/com/nolnoch/wifiauto/CustomReceiver.java	(working copy)

Property changes on: src/com/nolnoch/wifiauto/CustomReceiver.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: src/com/nolnoch/wifiauto/ManageActivity.java
===================================================================
--- src/com/nolnoch/wifiauto/ManageActivity.java	(revision 0)
+++ src/com/nolnoch/wifiauto/ManageActivity.java	(working copy)
@@ -0,0 +1,136 @@
+package com.nolnoch.wifiauto;
+
+import android.app.ListActivity;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.Button;
+import android.widget.CheckedTextView;
+import android.widget.ListView;
+import android.widget.SimpleCursorAdapter;
+import android.widget.TextView;
+
+public class ManageActivity extends ListActivity {
+	private SQLAdapter sqlAdapter;
+	private Cursor sqlCursor;
+	private static ComponentName component;
+	private static Button buttService;
+	private static TextView textview;
+	
+	@Override
+	public void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		setContentView(R.layout.managepage);
+		sqlAdapter = new SQLAdapter(this);
+		sqlAdapter.open();
+		sqlCursor = sqlAdapter.fetchAllLocations();
+		startManagingCursor(sqlCursor);
+		
+		Context pkg = getApplicationContext();
+		component = new ComponentName(pkg.getPackageName(), CustomReceiver.class.getName());
+		buttService = (Button) findViewById(R.id.buttservice);
+	  
+	}
+	  
+	public void fillData() {
+	
+		// Populate ListView from database
+		String[] from = new String[] {SQLAdapter.KEY_LABEL};
+		int[] to = new int[] {R.id.text1};
+	        
+		// Now create an array adapter and set it to display using our row
+		MyCursorAdapter labels = new MyCursorAdapter(this, R.layout.list_item, sqlCursor, from, to);
+		setListAdapter(labels);
+		
+		//Empower service button
+		Context pkg = getApplicationContext();
+		int io = pkg.getPackageManager().getComponentEnabledSetting(component);
+		int c = sqlCursor.getCount();
+		
+		if (c <= 0) {
+			buttService.setEnabled(false);
+			if (io == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
+				pkg.getPackageManager().setComponentEnabledSetting(component, PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
+				io = pkg.getPackageManager().getComponentEnabledSetting(component); }
+		} else if (c > 0) {
+			buttService.setEnabled(true);
+		}
+		
+		if (io == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
+			buttService.setText("Stop Service");
+		} else if ((io == PackageManager.COMPONENT_ENABLED_STATE_DISABLED) || (io == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT)) {
+			buttService.setText("Start Service");
+		}
+	     
+	}
+	
+	@Override
+    protected void onListItemClick(ListView l, View v, int position, long id) {
+        super.onListItemClick(l, v, position, id);
+        Cursor c = sqlCursor;
+        c.moveToPosition(position);
+        Intent i = new Intent(this, MapFrameActivity.class);
+        i.putExtra(SQLAdapter.KEY_ROWID, id);
+        i.putExtra(SQLAdapter.KEY_LABEL, c.getString(
+                c.getColumnIndexOrThrow(SQLAdapter.KEY_LABEL)));
+        i.putExtra(SQLAdapter.KEY_LATITUDE, c.getDouble(
+                c.getColumnIndexOrThrow(SQLAdapter.KEY_LATITUDE)));
+        i.putExtra(SQLAdapter.KEY_LONGITUDE, c.getDouble(
+                c.getColumnIndexOrThrow(SQLAdapter.KEY_LONGITUDE)));
+        i.putExtra(SQLAdapter.KEY_STATUS, c.getInt(
+                c.getColumnIndexOrThrow(SQLAdapter.KEY_STATUS)));
+        startActivity(i);
+    }
+	
+	private class MyCursorAdapter extends SimpleCursorAdapter {
+
+        public MyCursorAdapter(Context context, int layoutId, Cursor cur, String[] from, int[] to) {
+            super(context, layoutId, cur, from, to);
+        }
+
+        @Override
+        public void bindView(View view, Context context, Cursor cur) {
+            CheckedTextView checkTv = (CheckedTextView) view;
+            checkTv.setText(cur.getString(cur.getColumnIndex(SQLAdapter.KEY_LABEL)));
+            checkTv.setChecked((cur.getInt(cur.getColumnIndex(SQLAdapter.KEY_STATUS)))!=0);
+        }
+    }
+	
+	public void serviceClick(View view) {
+		Context pkg = getApplicationContext();
+		int io = pkg.getPackageManager().getComponentEnabledSetting(component);
+		textview = (TextView) getParent().findViewById(R.id.servicestatus);
+		if (io == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
+			pkg.getPackageManager().setComponentEnabledSetting(component, PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
+			buttService.setText("Start Service");
+			textview.setText("Service OFF");
+			textview.setTextColor(0x99FF3333);
+		} else if ((io == PackageManager.COMPONENT_ENABLED_STATE_DISABLED) || (io == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT)) {
+			pkg.getPackageManager().setComponentEnabledSetting(component, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP);
+			buttService.setText("Stop Service");
+			textview.setText("Service ON");
+			textview.setTextColor(0x9933FF33);
+		}
+	}
+	
+	@Override
+	protected void onPause() {
+		if (isFinishing())
+			sqlAdapter.close();
+		super.onPause();
+	}
+	@Override
+	protected void onResume() {
+		super.onResume();
+		fillData();
+	}
+	@Override
+	protected void onDestroy() {
+		sqlAdapter.close();
+		super.onDestroy();
+	}
+}
\ No newline at end of file
Index: src/com/nolnoch/wifiauto/ManageActivity.java
===================================================================
--- src/com/nolnoch/wifiauto/ManageActivity.java	(revision 14)
+++ src/com/nolnoch/wifiauto/ManageActivity.java	(working copy)

Property changes on: src/com/nolnoch/wifiauto/ManageActivity.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: src/com/nolnoch/wifiauto/ManualActivity.java
===================================================================
--- src/com/nolnoch/wifiauto/ManualActivity.java	(revision 0)
+++ src/com/nolnoch/wifiauto/ManualActivity.java	(working copy)
@@ -0,0 +1,173 @@
+package com.nolnoch.wifiauto;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Locale;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.ContentResolver;
+import android.content.Intent;
+import android.database.Cursor;
+import android.location.Address;
+import android.location.Geocoder;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.ContactsContract;
+import android.provider.ContactsContract.Contacts;
+import android.util.Log;
+import android.view.View;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.EditText;
+import android.widget.TabHost;
+
+public class ManualActivity extends Activity {
+	//Class variables
+	private static String streetvalue, cityvalue, statevalue, zipvalue, address;
+	private static EditText streetfield, cityfield, statefield, zipfield;
+	private static double coordLat;
+	private static double coordLong;
+	private AlertDialog.Builder alert;
+	private static final int CONTACT_PICKER_RESULT=1020, MAP_RESULT=1040;
+	private static InputMethodManager imm;
+		
+	//Manual acquisition of latitude and longitude.
+	public void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		setContentView(R.layout.manualpage);
+		streetfield = (EditText) findViewById(R.id.streetbox);
+		cityfield = (EditText) findViewById(R.id.citybox);
+		statefield = (EditText) findViewById(R.id.statebox);
+		zipfield = (EditText) findViewById(R.id.zipbox);
+		imm = (InputMethodManager) this.getSystemService(INPUT_METHOD_SERVICE);
+	}
+	
+	//Import Street, City, State, and Zip from contacts.
+	public void importContactInfo(View view) {
+		clearFields();
+		Intent contactPickerIntent = new Intent(Intent.ACTION_PICK, Contacts.CONTENT_URI);
+		startActivityForResult(contactPickerIntent, CONTACT_PICKER_RESULT);
+	}
+	
+	public void verify(View view) {
+		
+		streetvalue = streetfield.getText().toString();
+		cityvalue = cityfield.getText().toString();
+		statevalue = statefield.getText().toString();
+		zipvalue = zipfield.getText().toString();
+		alert = new AlertDialog.Builder(ManualActivity.this).setTitle("Incomplete").setMessage("Street with City/State or Zip required.").setNeutralButton("Close", null);
+		
+		if ((!streetvalue.contentEquals("")) && ((!zipvalue.contentEquals("")) || ( (!cityvalue.contentEquals("") ) && (!statevalue.contentEquals("") )))) {
+			addressLookup(); } else {alert.show(); }
+	}
+	
+	public void addressLookup() {
+
+		alert = new AlertDialog.Builder(ManualActivity.this).setTitle("Address Not Found").setMessage("Please use Automatic Tab.").setNeutralButton("Close", null);
+		
+		if (!zipvalue.contentEquals("")) {
+			address = streetvalue + ", " + zipvalue;} else {
+			address = streetvalue + ", " + cityvalue + ", " + statevalue; }
+		
+		Geocoder geodex = new Geocoder(getApplicationContext(), Locale.US);
+		try {
+			List<Address> coordlist = geodex.getFromLocationName(address, 1);
+			if (coordlist != null) {
+				coordLat = coordlist.get(0).getLatitude();
+				coordLong = coordlist.get(0).getLongitude();
+				Intent mapIntent = new Intent(ManualActivity.this, MapFrameActivity.class);
+				mapIntent.putExtra("latitude", coordLat);
+				mapIntent.putExtra("longitude", coordLong);
+				startActivityForResult(mapIntent, MAP_RESULT);
+			} else {
+				alert.show();
+			}
+		} catch (IOException e) {
+			new AlertDialog.Builder(ManualActivity.this).setTitle("Maps Not Found").setMessage("Install Google Maps or use Automatic Tab.").setNeutralButton("Close", null).show();
+			Log.e("IOException", e.getMessage());
+		}
+	}
+	
+	public void clearFields() {
+		EditText[] locFields = {streetfield, cityfield, statefield, zipfield};
+		for (int i = 0; i < locFields.length; i++) {
+			locFields[i].setText("");
+		}
+		streetvalue = cityvalue = statevalue = zipvalue = "";
+	}
+	
+	@Override
+	public void onActivityResult(int requestCode, int resultCode, Intent intent) {
+		if (resultCode == RESULT_OK) {
+			switch (requestCode) {
+			case CONTACT_PICKER_RESULT:
+				try {
+					//attempt fetch of address
+					Cursor addrCur = null;
+					Uri contactUri = intent.getData();
+					String contactId = contactUri.getLastPathSegment();
+					ContentResolver cr = getContentResolver();
+					String addrWhere = ContactsContract.Data.CONTACT_ID + " = ? AND " + ContactsContract.Data.MIMETYPE + " = ?"; 
+					String[] addrWhereParams = new String[]{contactId, ContactsContract.CommonDataKinds.StructuredPostal.CONTENT_ITEM_TYPE}; 
+					addrCur = cr.query(ContactsContract.Data.CONTENT_URI, null, addrWhere, addrWhereParams, null); 
+					if (addrCur.moveToNext()) {
+						streetvalue = addrCur.getString(
+							addrCur.getColumnIndex(ContactsContract.CommonDataKinds.StructuredPostal.STREET));
+						cityvalue = addrCur.getString(
+							addrCur.getColumnIndex(ContactsContract.CommonDataKinds.StructuredPostal.CITY));
+						statevalue = addrCur.getString(
+							addrCur.getColumnIndex(ContactsContract.CommonDataKinds.StructuredPostal.REGION));
+						zipvalue = addrCur.getString(
+							addrCur.getColumnIndex(ContactsContract.CommonDataKinds.StructuredPostal.POSTCODE));
+					} else {
+						Log.w("DEBUG", "No results found");
+						streetvalue = cityvalue = statevalue = zipvalue = "";
+					}
+					if (addrCur != null)
+						addrCur.close();
+				} catch (Exception e) {
+					//report a failed lookup
+					alert = new AlertDialog.Builder(ManualActivity.this).setTitle("Error").setMessage("Contact address lookup failed.").setNeutralButton("Close", null);
+					alert.show();
+					Log.e("DEBUG", "Failed to fetch address", e);
+				} finally {
+					//check for and assign retrieved values
+					EditText[] locFields = {streetfield, cityfield, statefield, zipfield};
+					String[] locValues = {streetvalue, cityvalue, statevalue, zipvalue};
+					int i, j = 0;
+					for (i = 0; i < locValues.length; i++) {
+						if (locValues[i] == null)
+							locValues[i] = "";
+						boolean isField = locValues[i].length() != 0;
+						locFields[i].setText(isField ? locValues[i] : "");
+						if (isField)
+							j++;
+					}
+					if (j == 0) {
+						alert = new AlertDialog.Builder(ManualActivity.this).setTitle("Empty").setMessage("Contact returned no address.").setNeutralButton("Close", null);
+						alert.show();
+					}
+				}
+				break;
+			case MAP_RESULT:
+				clearFields();
+				TabHost tabHost =  (TabHost) getParent().findViewById(android.R.id.tabhost);
+	            tabHost.setCurrentTab(2);
+				break;
+			default:
+				Log.w("DEBUG", "Activity not prepared to handle request");
+				break;
+			}
+		} else {
+			Log.w("DEBUG", "Activity result not OK");
+		}
+	}
+	
+	@Override
+	public void onResume() {
+		super.onResume();
+		imm.hideSoftInputFromWindow(streetfield.getWindowToken(), 0);
+		imm.hideSoftInputFromWindow(zipfield.getWindowToken(), 0);
+	}
+
+}
\ No newline at end of file
Index: src/com/nolnoch/wifiauto/ManualActivity.java
===================================================================
--- src/com/nolnoch/wifiauto/ManualActivity.java	(revision 13)
+++ src/com/nolnoch/wifiauto/ManualActivity.java	(working copy)

Property changes on: src/com/nolnoch/wifiauto/ManualActivity.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: src/com/nolnoch/wifiauto/MapFrameActivity.java
===================================================================
--- src/com/nolnoch/wifiauto/MapFrameActivity.java	(revision 0)
+++ src/com/nolnoch/wifiauto/MapFrameActivity.java	(working copy)
@@ -0,0 +1,190 @@
+package com.nolnoch.wifiauto;
+
+import java.util.List;
+
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.TextView;
+
+import com.google.android.maps.GeoPoint;
+import com.google.android.maps.MapActivity;
+import com.google.android.maps.MapController;
+import com.google.android.maps.MapView;
+import com.google.android.maps.Overlay;
+import com.google.android.maps.OverlayItem;
+
+public class MapFrameActivity extends MapActivity {
+	private static double lat;
+	private static double lon;
+	private static int i;
+	private static Button b;
+	private static TextView tv;
+	private AlertDialog.Builder alert;
+	private SQLAdapter sqlAdapter;
+	
+	@Override
+	protected boolean isRouteDisplayed() {
+		return false;
+	}
+	@Override
+	public void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		if (getIntent().hasExtra(SQLAdapter.KEY_LABEL)) {
+			setContentView(R.layout.editdialog);
+			format();}
+		else {setContentView(R.layout.mapdialog); }
+		
+		MapView mapbox = (MapView) findViewById(R.id.mapbox);
+		mapbox.setBuiltInZoomControls(true);
+		
+		List<Overlay> mapOverlays = mapbox.getOverlays();
+		Drawable drawable = this.getResources().getDrawable(android.R.drawable.ic_notification_overlay);
+		MapOverlayActivity overlayMarker = new MapOverlayActivity(drawable);
+		
+		lat = getIntent().getDoubleExtra(SQLAdapter.KEY_LATITUDE, 0);
+		lon = getIntent().getDoubleExtra(SQLAdapter.KEY_LONGITUDE, 0);
+		
+		GeoPoint point = new GeoPoint((int)(lat*1E6), (int)(lon*1E6));
+		OverlayItem markPoint = new OverlayItem(point, "", "");
+		
+		overlayMarker.addOverlay(markPoint);
+		mapOverlays.add(overlayMarker);
+		
+		MapController mcontrol = mapbox.getController();
+		mcontrol.animateTo(point);
+		mcontrol.setZoom(18);
+		
+		sqlAdapter = new SQLAdapter(this);
+		sqlAdapter.open();
+		
+	}
+	
+	public void format() {
+		i = getIntent().getIntExtra("status", 1);
+		buttSwitch();
+		
+		tv = (TextView) findViewById(R.id.showlabel);
+		String s = "Name: " + getIntent().getStringExtra("label");
+		tv.setText(s);
+		tv = (TextView) findViewById(R.id.showlat);
+		double d = getIntent().getDoubleExtra("latitude", 0);
+		s = "Latitude: " + Double.toString(d);
+		tv.setText(s);
+		tv = (TextView) findViewById(R.id.showlon);
+		d = getIntent().getDoubleExtra("longitude", 0);
+		s = "Longitude: " + Double.toString(d);
+		tv.setText(s);
+	}
+	
+	public void buttSwitch() {
+		tv = (TextView) findViewById(R.id.showstatus);
+		b = (Button) findViewById(R.id.buttstatus);
+		if (i == 0) {
+			b.setText(getString(R.string.button_enable));
+			tv.setText("Status: Disabled"); }
+		else {b.setText(getString(R.string.button_disable));
+			tv.setText("Status: Enabled"); }
+	}
+	
+	public void yesClick(View view) {
+		alert = new AlertDialog.Builder(MapFrameActivity.this);
+		alert.setTitle("Success").setMessage("Enter a name for this location.");
+
+		final EditText input = new EditText(MapFrameActivity.this);
+		alert.setView(input);
+
+		alert.setPositiveButton("Ok", new DialogInterface.OnClickListener() {
+		public void onClick(DialogInterface dialog, int whichButton) {
+			String name = input.getText().toString();
+			sqlAdapter.createLocation(name, lat, lon, 1);
+			terminate();
+		  }
+		});
+
+		alert.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
+		  public void onClick(DialogInterface dialog, int whichButton) {
+			  terminate();
+		  }
+		});
+
+		alert.show();
+	}
+	
+	public void noClick(View view) {
+		alert = new AlertDialog.Builder(MapFrameActivity.this);
+		alert.setTitle("Sorry").setMessage("Please try again or use alternate method.");
+		alert.setNeutralButton("Close", new DialogInterface.OnClickListener() {
+			public void onClick(DialogInterface dialog, int id) {
+				finish(); }});
+		alert.show();
+	}
+	
+	public void editClick(View view) {
+		alert = new AlertDialog.Builder(MapFrameActivity.this);
+		alert.setTitle("Rename").setMessage("Enter a new name for this location.");
+
+		final EditText input = new EditText(MapFrameActivity.this);
+		alert.setView(input);
+
+		alert.setPositiveButton("Ok", new DialogInterface.OnClickListener() {
+		public void onClick(DialogInterface dialog, int whichButton) {
+			long locId = getIntent().getLongExtra(SQLAdapter.KEY_ROWID, 0);
+			String name = input.getText().toString();
+			sqlAdapter.updateLocation(locId, name, lat, lon, 1);
+			terminate();
+		  }
+		});
+
+		alert.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
+		  public void onClick(DialogInterface dialog, int whichButton) {
+			  terminate();
+		  }
+		});
+
+		alert.show();
+	}
+	
+	public void statusClick(View view) {
+		long locId = getIntent().getLongExtra(SQLAdapter.KEY_ROWID, 0);
+		String name = getIntent().getStringExtra(SQLAdapter.KEY_LABEL);
+		if (i == 0) {
+			sqlAdapter.updateLocation(locId, name, lat, lon, 1);
+			i = 1; }
+		else {
+			sqlAdapter.updateLocation(locId, name, lat, lon, 0);
+			i = 0; }
+		buttSwitch();
+	}
+	
+	public void deleteClick(View view) {
+		long locId = getIntent().getLongExtra(SQLAdapter.KEY_ROWID, 0);
+		sqlAdapter.deleteLocation(locId);
+		terminate();
+	}
+	
+	public void closeClick(View view) {
+		terminate();
+	}
+	
+	public void terminate() {
+		setResult(RESULT_OK);
+		finish();
+	}
+	
+	@Override
+	protected void onPause() {
+		super.onPause();
+		if (isFinishing())
+			sqlAdapter.close();
+	}
+	@Override
+	protected void onDestroy() {
+		sqlAdapter.close();
+		super.onDestroy();
+	}
+}
Index: src/com/nolnoch/wifiauto/MapFrameActivity.java
===================================================================
--- src/com/nolnoch/wifiauto/MapFrameActivity.java	(revision 13)
+++ src/com/nolnoch/wifiauto/MapFrameActivity.java	(working copy)

Property changes on: src/com/nolnoch/wifiauto/MapFrameActivity.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: src/com/nolnoch/wifiauto/MapOverlayActivity.java
===================================================================
--- src/com/nolnoch/wifiauto/MapOverlayActivity.java	(revision 0)
+++ src/com/nolnoch/wifiauto/MapOverlayActivity.java	(working copy)
@@ -0,0 +1,32 @@
+package com.nolnoch.wifiauto;
+
+import java.util.ArrayList;
+
+import android.graphics.drawable.Drawable;
+
+import com.google.android.maps.ItemizedOverlay;
+import com.google.android.maps.OverlayItem;
+
+public class MapOverlayActivity extends ItemizedOverlay<OverlayItem> {
+	
+	private ArrayList<OverlayItem> mapoverlay = new ArrayList<OverlayItem>();
+	
+	public MapOverlayActivity(Drawable defaultMarker) {
+		super(boundCenterBottom(defaultMarker));
+	}
+	
+	public void addOverlay(OverlayItem overlay) {
+	    mapoverlay.add(overlay);
+	    populate();
+	}
+	
+	@Override
+	protected OverlayItem createItem(int i) {
+		return mapoverlay.get(i);
+	}
+	
+	@Override
+	public int size() {
+		return mapoverlay.size();
+	}
+}
Index: src/com/nolnoch/wifiauto/MapOverlayActivity.java
===================================================================
--- src/com/nolnoch/wifiauto/MapOverlayActivity.java	(revision 3)
+++ src/com/nolnoch/wifiauto/MapOverlayActivity.java	(working copy)

Property changes on: src/com/nolnoch/wifiauto/MapOverlayActivity.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: src/com/nolnoch/wifiauto/ProximityMachine.java
===================================================================
--- src/com/nolnoch/wifiauto/ProximityMachine.java	(revision 0)
+++ src/com/nolnoch/wifiauto/ProximityMachine.java	(working copy)
@@ -0,0 +1,249 @@
+package com.nolnoch.wifiauto;
+
+import android.app.Service;
+import android.content.Intent;
+import android.database.Cursor;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.location.LocationProvider;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.wifi.WifiManager;
+import android.os.Bundle;
+import android.os.CountDownTimer;
+import android.os.IBinder;
+import android.telephony.TelephonyManager;
+
+public class ProximityMachine extends Service {
+	private static LocationManager locationManager;
+	private static WifiManager wifiManager;
+	private static TelephonyManager teleManager;
+	private static Location finalLocation;
+	private static LocationListener locationListener;
+	private static final int TWO_MINUTES = 120000;
+	private static final int MODE_NETWORK = 1, MODE_GPS = 2, PRELIMINARY = 1, FINAL = 2;
+	private static final int MODE_ALL = MODE_NETWORK | MODE_GPS;
+	private static final int PRELIM_DELTA = 800;
+	private static final long ONE_SECOND = 1000;
+	private static int c, tick, callStatus, whichRound;
+	private static boolean wifiEnabled, gpsEnabled, wifiConnected, cellAvailable, ticktock;
+	private SQLAdapter sqlAdapter;
+	private Cursor sqlCursor;
+	public static int setFinalDelta = 80;
+	public static int setTimeout = 25;
+	
+	private CountDownTimer timeout = new CountDownTimer(ONE_SECOND*setTimeout, ONE_SECOND) {
+	     public void onTick(long remainder) {}
+
+	     public void onFinish() {
+	    	endListener();
+	    	ticktock = false;
+	    	if (finalLocation != null) {
+				process(finalLocation);
+	    	} else {
+				stopSelf();
+			}
+	     }
+	  };
+	
+	@Override
+	public IBinder onBind(Intent intent) {
+		return null;
+	}
+	
+	@Override
+	public void onCreate() {
+		
+		wifiManager = (WifiManager) this.getSystemService(WIFI_SERVICE);
+		locationManager = (LocationManager) this.getSystemService(LOCATION_SERVICE);
+		teleManager = (TelephonyManager) this.getSystemService(TELEPHONY_SERVICE);
+		ConnectivityManager conManager = (ConnectivityManager) this.getSystemService(CONNECTIVITY_SERVICE);
+		NetworkInfo wifiCon = conManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
+		NetworkInfo cellCon = conManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
+		
+		finalLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
+		
+		gpsEnabled = (locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER));
+		wifiEnabled = (wifiManager.isWifiEnabled());
+		wifiConnected = wifiCon.isConnected();
+		cellAvailable = cellCon.isAvailable();
+		callStatus = teleManager.getCallState();
+		ticktock = false;
+		
+		sqlAdapter = new SQLAdapter(this);
+		sqlAdapter.open();
+		sqlCursor = sqlAdapter.fetchAllLocations();    	
+	}
+	
+	@Override
+	public int onStartCommand(Intent intent, int flags, int id) {
+		
+		switch(callStatus) {
+		case TelephonyManager.CALL_STATE_OFFHOOK:
+		case TelephonyManager.CALL_STATE_RINGING:
+			stopSelf();
+			break;
+		case TelephonyManager.CALL_STATE_IDLE:
+		default:
+			break;
+		}
+		
+		c = sqlCursor.getCount();
+		
+		if ( (c <= 0) || (wifiConnected) || (!gpsEnabled && !wifiEnabled && !cellAvailable) ) {
+			stopSelf();
+			return START_NOT_STICKY;
+		}
+		
+		locationListener = new LocationListener() {
+    		public void onLocationChanged(Location location) {
+    			if (isBetterLocation(location, finalLocation)) {
+    	    		finalLocation = location; }
+    			tick++;
+    			if (tick >= whichRound) {
+    				timeout.cancel();
+    				endListener();
+    				ticktock = false;
+    				process(finalLocation);
+    			}
+    		}
+    		public void onStatusChanged(String provider, int status, Bundle extras) {
+    			if (status == LocationProvider.OUT_OF_SERVICE)
+    				stopSelf();
+    		}
+    		public void onProviderEnabled(String provider) {}
+    		public void onProviderDisabled(String provider) {
+    			stopSelf();
+    		}
+    	};
+    	
+    	if (gpsEnabled) {
+    		if (wifiEnabled || cellAvailable) {
+    			findLocation(MODE_NETWORK, PRELIMINARY);
+    		} else {
+    			findLocation(MODE_GPS, FINAL);
+    		}
+    	} else {
+    		if (wifiEnabled || cellAvailable) {
+    			findLocation(MODE_NETWORK, FINAL);
+    		} else {
+    			stopSelf();
+    		}
+    	}
+    		
+    	return START_NOT_STICKY;
+	}
+	
+	private void findLocation(int mode, int round) {		
+		whichRound = round;
+    	tick = 0;
+    	ticktock = true;
+		
+		if ((mode & MODE_NETWORK) > 0)
+			locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 0, 0, locationListener);
+    	if ((mode & MODE_GPS) > 0)
+    		locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);
+    	
+    	timeout.start();
+	}
+	
+	private void process(Location currentLocation) {
+		
+		int io = 0;
+		int processDelta = whichRound > 1 ? setFinalDelta : PRELIM_DELTA;
+		
+		for (int i = 0; i < c; i++) {
+			sqlCursor.moveToPosition(i);
+			int s = sqlCursor.getInt(sqlCursor.getColumnIndexOrThrow(SQLAdapter.KEY_STATUS));
+			if (s == 1) {
+				Location storedLocation = new Location("");
+				storedLocation.setLatitude(sqlCursor.getDouble(sqlCursor.getColumnIndexOrThrow(SQLAdapter.KEY_LATITUDE)));
+				storedLocation.setLongitude(sqlCursor.getDouble(sqlCursor.getColumnIndexOrThrow(SQLAdapter.KEY_LONGITUDE)));
+				float delta = storedLocation.distanceTo(currentLocation);
+				if (delta <= processDelta)
+					io++;
+			}
+		}
+		
+		if (io == 0) {
+			wifiManager.setWifiEnabled(false);
+			stopSelf();
+		} else if (io * whichRound > io) {
+			wifiManager.setWifiEnabled(true);
+			stopSelf();
+		} else
+			findLocation(MODE_ALL, FINAL);				
+	}
+	
+	private boolean isBetterLocation(Location location, Location currentBestLocation) {
+        if (currentBestLocation == null) {
+            // A new location is always better than no location
+            return true;
+        }
+
+        // Check whether the new location fix is newer or older
+        long timeDelta = location.getTime() - currentBestLocation.getTime();
+        boolean isSignificantlyNewer = timeDelta > TWO_MINUTES;
+        boolean isSignificantlyOlder = timeDelta < -TWO_MINUTES;
+        boolean isNewer = timeDelta > 0;
+
+        // If it's been more than two minutes since the current location, use the new location
+        // because the user has likely moved
+        if (isSignificantlyNewer) {
+            return true;
+        // If the new location is more than two minutes older, it must be worse
+        } else if (isSignificantlyOlder) {
+            return false;
+        }
+
+        // Check whether the new location fix is more or less accurate
+        int accuracyDelta = (int) (location.getAccuracy() - currentBestLocation.getAccuracy());
+        boolean isLessAccurate = accuracyDelta > 0;
+        boolean isMoreAccurate = accuracyDelta < 0;
+        boolean isSignificantlyLessAccurate = accuracyDelta > 200;
+
+        // Check if the old and new location are from the same provider
+        boolean isFromSameProvider = isSameProvider(location.getProvider(),
+                currentBestLocation.getProvider());
+
+        // Determine location quality using a combination of timeliness and accuracy
+        if (isMoreAccurate) {
+            return true;
+        } else if (isNewer && !isLessAccurate) {
+            return true;
+        } else if (isNewer && !isSignificantlyLessAccurate && isFromSameProvider) {
+            return true;
+        }
+        return false;
+    }
+
+    /** Checks whether two providers are the same */
+    private boolean isSameProvider(String provider1, String provider2) {
+        if (provider1 == null) {
+          return provider2 == null;
+        }
+        return provider1.equals(provider2);
+    }
+    
+    private void endListener() {
+    	locationManager.removeUpdates(locationListener);
+    	ticktock = false;
+		tick = 0;
+    }
+        
+    private void terminate() {
+    	sqlCursor.close();
+    	sqlAdapter.close();
+    	if (ticktock) {
+    		timeout.cancel();
+    		endListener();
+    	}
+    }
+    
+    @Override
+    public void onDestroy() {
+    	terminate();
+    }
+
+}
Index: src/com/nolnoch/wifiauto/ProximityMachine.java
===================================================================
--- src/com/nolnoch/wifiauto/ProximityMachine.java	(revision 14)
+++ src/com/nolnoch/wifiauto/ProximityMachine.java	(working copy)

Property changes on: src/com/nolnoch/wifiauto/ProximityMachine.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: src/com/nolnoch/wifiauto/SQLAdapter.java
===================================================================
--- src/com/nolnoch/wifiauto/SQLAdapter.java	(revision 0)
+++ src/com/nolnoch/wifiauto/SQLAdapter.java	(working copy)
@@ -0,0 +1,114 @@
+package com.nolnoch.wifiauto;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+
+public class SQLAdapter {
+	
+	public final static String KEY_LABEL = "label";
+    public final static String KEY_LATITUDE = "latitude";
+    public final static String KEY_LONGITUDE = "longitude";
+    public final static String KEY_STATUS = "status";
+    public final static String KEY_ROWID = "_id";
+
+    private static final String TAG = "rainbowSQLAdapter";
+    private SQLSetup dbSetup;
+    private SQLiteDatabase sqlDb;
+	
+    private final Context dbContext;
+	
+	private static final String DATABASE_NAME = "PointsOfDesire";
+	private static final String DATABASE_TABLE = "rainbow";
+	private static final int DATABASE_VERSION = 1;
+	private static final String DATABASE_CREATE =
+			"create table rainbow (_id integer primary key autoincrement, "
+			+ "label text not null, latitude real not null, "
+			+ "longitude real not null, status integer not null);";
+	
+	private static class SQLSetup extends SQLiteOpenHelper {
+		
+		public SQLSetup(Context context) {
+			super(context, DATABASE_NAME, null, DATABASE_VERSION);
+			
+		}
+
+		@Override
+		public void onCreate(SQLiteDatabase db) {
+			db.execSQL(DATABASE_CREATE);
+
+		}
+
+		@Override
+		public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+			Log.w(TAG, "Upgrading database from version " + oldVersion + " to "
+                    + newVersion + ", which will destroy all old data");
+            db.execSQL("DROP TABLE IF EXISTS rainbow");
+            onCreate(db);
+
+		}
+	}
+	
+	public SQLAdapter(Context context) {
+		this.dbContext = context;
+	}
+	
+	public SQLAdapter open() throws SQLException {
+		dbSetup = new SQLSetup(dbContext);
+		sqlDb = dbSetup.getWritableDatabase();
+		return this;
+	}
+	
+	public void close() {
+		dbSetup.close();
+	}
+	
+	public long createLocation(String label, double latitude, double longitude, int status) {
+	    ContentValues initialValues = new ContentValues();
+	    initialValues.put(KEY_LABEL, label);
+	    initialValues.put(KEY_LATITUDE, latitude);
+	    initialValues.put(KEY_LONGITUDE, longitude);
+	    initialValues.put(KEY_STATUS, status);
+
+        return sqlDb.insert(DATABASE_TABLE, null, initialValues);
+    }
+	
+	public boolean deleteLocation(long rowId) {
+
+        return sqlDb.delete(DATABASE_TABLE, KEY_ROWID + "=" + rowId, null) > 0;
+    }
+	
+	public Cursor fetchAllLocations() {
+
+        return sqlDb.query(DATABASE_TABLE, new String[] {KEY_ROWID, KEY_LABEL, KEY_LATITUDE, KEY_LONGITUDE, KEY_STATUS}, null, null, null, null, null);
+    }
+	
+	public Cursor fetchLocation(long rowId) throws SQLException {
+
+        Cursor mCursor =
+
+            sqlDb.query(true, DATABASE_TABLE, new String[] {KEY_ROWID,
+                    KEY_LABEL, KEY_LATITUDE, KEY_LONGITUDE, KEY_STATUS}, KEY_ROWID + "=" + rowId, null,
+                    null, null, null, null);
+        if (mCursor != null) {
+            mCursor.moveToFirst();
+        }
+        return mCursor;
+
+    }
+	
+	public boolean updateLocation(long rowId, String label, double latitude, double longitude, int status) {
+        ContentValues args = new ContentValues();
+        args.put(KEY_LABEL, label);
+        args.put(KEY_LATITUDE, latitude);
+        args.put(KEY_LONGITUDE, longitude);
+        args.put(KEY_STATUS, status);
+
+        return sqlDb.update(DATABASE_TABLE, args, KEY_ROWID + "=" + rowId, null) > 0;
+    }
+
+}
Index: src/com/nolnoch/wifiauto/SQLAdapter.java
===================================================================
--- src/com/nolnoch/wifiauto/SQLAdapter.java	(revision 3)
+++ src/com/nolnoch/wifiauto/SQLAdapter.java	(working copy)

Property changes on: src/com/nolnoch/wifiauto/SQLAdapter.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: src/com/nolnoch/wifiauto/WifiAutoToggleActivity.java
===================================================================
--- src/com/nolnoch/wifiauto/WifiAutoToggleActivity.java	(revision 0)
+++ src/com/nolnoch/wifiauto/WifiAutoToggleActivity.java	(working copy)
@@ -0,0 +1,294 @@
+package com.nolnoch.wifiauto;
+
+import java.util.List;
+
+import android.app.AlertDialog;
+import android.app.TabActivity;
+import android.content.ActivityNotFoundException;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.res.Resources;
+import android.location.LocationManager;
+import android.net.Uri;
+import android.net.wifi.WifiManager;
+import android.os.Bundle;
+import android.os.Handler;
+import android.provider.Settings;
+import android.util.Log;
+import android.view.View;
+import android.widget.TabHost;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.google.android.vending.licensing.AESObfuscator;
+import com.google.android.vending.licensing.LicenseChecker;
+import com.google.android.vending.licensing.LicenseCheckerCallback;
+import com.google.android.vending.licensing.Policy;
+import com.google.android.vending.licensing.ServerManagedPolicy;
+
+public class WifiAutoToggleActivity extends TabActivity {
+    /** Called when the activity is first created. */
+	
+	//Anchor Wifi and GPS service connections.
+	public static WifiManager wifiManager;
+    public static LocationManager locationManager;
+    private static TextView textview;
+    private static ComponentName component;
+    
+    //Licensing infrastructure declarations
+    private static final String BASE64_PUBLIC_KEY = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzwhB2uJmct/EBFitPAIbEkGRyxzoGJVhS5ETpUjdXZu4J9tcaNRNFHhJu3g+UTzsJRDxRMUzyk+/mX+JaR4b6pRz/POdYsqUiglTq6M3c/tS8WG/SqX7wv8W220EPh78g8vNTFpif0o4GCHFbMycGwPf1WFysRXXW1ASX/OqXFnB7UeAtspB5yhy6jBjbTCD3dZ6EoNtTb768+tS3uQkZVMwzbROf7/UwYm4+tWXpBQBtw8PwmaW6hfja2z8arUyBmSbesshs9KQUXaV4RRrSitptumNiRws76+BUb6BUxL8Q5XFO/c5tBX7Ee+i1/GMQjIDWFGwjv8oJHeeX2KpowIDAQAB";
+    private static final byte[] SALT =
+        { 36, -70, 51, -89, -12, 12, 107, -34, -27, 91, 43, 62, -40, -13, 54, 81, 37, -21, -4, 73};
+    private static final int RETRY = 0x04, MARKET = 0x08;
+    private static MyLicenseCheckerCallback mLicenseCheckerCallback;
+	private static LicenseChecker mChecker;
+	private static String deviceId;
+    
+	private Handler mHandler;
+	private AlertDialog.Builder licenseDialog;
+    
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+
+        Resources res = getResources(); // Resource object to get Drawables
+        TabHost tabHost = getTabHost();  // The activity TabHost
+        TabHost.TabSpec spec;  // Reusable TabSpec for each tab
+        Intent intent;  // Reusable Intent for each tab
+
+        // Create an Intent to launch an Activity for the tab (to be reused)
+        intent = new Intent().setClass(this, AutomaticActivity.class);
+
+        // Initialize a TabSpec for each tab and add it to the TabHost
+        spec = tabHost.newTabSpec("automatic").setIndicator("Automatic",
+                res.getDrawable(R.drawable.ic_tab_auto))
+                      .setContent(intent);
+        tabHost.addTab(spec);
+
+        // Do the same for the other tabs
+        intent = new Intent().setClass(this, ManualActivity.class);
+        spec = tabHost.newTabSpec("manual").setIndicator("Manual",
+                res.getDrawable(R.drawable.ic_tab_manual))
+                      .setContent(intent);
+        tabHost.addTab(spec);
+
+        intent = new Intent().setClass(this, ManageActivity.class);
+        spec = tabHost.newTabSpec("manage").setIndicator("Manage",
+                res.getDrawable(R.drawable.ic_tab_manage))
+                      .setContent(intent);
+        tabHost.addTab(spec);
+
+       	tabHost.setCurrentTab(0);
+       	
+       	Context pkg = getApplicationContext();
+		component = new ComponentName(pkg.getPackageName(), CustomReceiver.class.getName());
+       	
+       	wifiManager = (WifiManager) this.getSystemService(Context.WIFI_SERVICE);
+		locationManager = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE);
+		
+		mHandler = new Handler();
+		
+		//Check License against Google Play servers
+		runCheckLicense();
+        
+    }
+    
+    protected void runCheckLicense() {
+    	//TODO increase security of deviceId
+        deviceId = Settings.Secure.getString(getContentResolver(), Settings.Secure.ANDROID_ID);
+        
+     	//Construct the LicenseCheckerCallback. The library calls this when done.
+        mLicenseCheckerCallback = new MyLicenseCheckerCallback();
+
+        // Construct the LicenseChecker with a Policy.
+        mChecker = new LicenseChecker(
+            this, new ServerManagedPolicy(this,
+                new AESObfuscator(SALT, getPackageName(), deviceId)),
+            BASE64_PUBLIC_KEY
+            );
+        
+        doCheck();
+    }
+    
+    protected void serviceStatus() {
+		textview = (TextView) findViewById(R.id.GPSstatus);		
+		if (locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {
+        	textview.setText("GPS ON");
+        	textview.setTextColor(0x9933FF33);
+        } else {
+        	textview.setText("GPS OFF");
+        	textview.setTextColor(0x99FF3333);
+        }
+        textview = (TextView) findViewById(R.id.WIFIstatus);
+        if (wifiManager.isWifiEnabled()) {
+        	textview.setText("WiFi ON");
+        	textview.setTextColor(0x9933FF33);
+        } else {
+        	textview.setText("WiFi OFF");
+        	textview.setTextColor(0x99FF3333);
+        }
+        textview = (TextView) findViewById(R.id.servicestatus);
+        Context pkg = getApplicationContext();
+		int io = pkg.getPackageManager().getComponentEnabledSetting(component);
+		if (io == PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
+			textview.setText("Service ON");
+			textview.setTextColor(0x9933FF33);
+		} else if ((io == PackageManager.COMPONENT_ENABLED_STATE_DISABLED) || (io == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT)) {
+			textview.setText("Service OFF");
+			textview.setTextColor(0x99FF3333);
+		}
+        
+    }
+    
+  //TextView-click method to launch settings menu
+  	protected void changeSettings(View view) {
+  		//Catch-all menu for all devices
+  		Intent settingsIntent = new Intent(Settings.ACTION_WIRELESS_SETTINGS);
+  		Intent tmpIntent;
+  		
+  		//Assign specifically requested menu for devices that have them 
+  		switch (view.getId()) {
+  		case R.id.GPSstatus:
+  			tmpIntent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS);
+  			if (isCallable(tmpIntent))
+  				settingsIntent = tmpIntent;
+  			break;
+  		case R.id.WIFIstatus:
+  			tmpIntent = new Intent(Settings.ACTION_WIFI_SETTINGS);
+  			if (isCallable(tmpIntent))
+  				settingsIntent = tmpIntent;
+  			break;
+  		default:			
+  			break;
+  		}
+  		
+  		//Launch menu
+  		try {
+  			startActivity(settingsIntent);
+  		} catch (ActivityNotFoundException e) {
+  			new AlertDialog.Builder(WifiAutoToggleActivity.this).setTitle("Menu Not Found").setMessage("Could not launch chosen Settings menu.").setNeutralButton("Close", null).show();
+  			Log.e("DEBUG", e.getMessage());
+  		}
+  	}
+  	
+  	private class MyLicenseCheckerCallback implements LicenseCheckerCallback {
+  	    
+  		public void allow(int reason) {
+  	        if (isFinishing()) {
+  	            // Don't update UI if Activity is finishing.
+  	            return;
+  	        }
+  	        // Should allow user access.
+  	        // Do nothing apparent.  Or really, do nothing at all.
+  	    }
+
+  	    public void dontAllow(int reason) {
+  	        if (isFinishing()) {
+  	            // Don't update UI if Activity is finishing.
+  	            return;
+  	        }  	        
+  	        if (reason == Policy.RETRY) {
+  	            // If the reason received from the policy is RETRY, it was probably
+  	            // due to a loss of connection with the service, so we should give the
+  	            // user a chance to retry. So show a dialog to retry.
+  	            displayResult(RETRY);
+  	        } else {
+  	            // Otherwise, the user is not licensed to use this app.
+  	            // Your response should always inform the user that the application
+  	            // is not licensed, but your behavior at that point can vary. You might
+  	            // provide the user a limited access version of your app or you can
+  	            // take them to Google Play to purchase the app.
+  	            displayResult(MARKET);
+  	        }
+  	    }
+  	    
+  	    public void applicationError(int errorCode) {
+  	    	switch(errorCode) {
+  	    	case ERROR_INVALID_PACKAGE_NAME:
+  	    	case ERROR_NON_MATCHING_UID:
+  	    	case ERROR_NOT_MARKET_MANAGED:
+  	    	case ERROR_CHECK_IN_PROGRESS:
+  	    	case ERROR_INVALID_PUBLIC_KEY:
+  	    	case ERROR_MISSING_PERMISSION:
+  	    	default:
+  	    		break;
+  	    	}
+  	    }
+  	    
+  	    private void displayResult(final int result) {
+  	    	mHandler.post(new Runnable() {
+  	    		public void run() {
+  	    			licenseDialog = new AlertDialog.Builder(WifiAutoToggleActivity.this).setCancelable(false)
+  	    				.setNegativeButton("Exit", new DialogInterface.OnClickListener() {
+						
+						public void onClick(DialogInterface dialog, int which) {
+							WifiAutoToggleActivity.this.finish();
+							
+						}
+					});
+  	    			
+  	    			switch(result) {
+  	    			case RETRY:
+  	    				licenseDialog.setTitle("License Check Error")
+  	    					.setMessage("License check incomplete due to network problems. Unauthorized use of this application not permitted. Check mobile or WiFi connectivity and try again. Retry now or later?")
+  	    					.setPositiveButton("Retry", new DialogInterface.OnClickListener() {
+								
+								public void onClick(DialogInterface dialog, int which) {
+									doCheck();
+									
+								}
+							});
+  	    				break;
+  	    			case MARKET:
+  	    				licenseDialog.setTitle("License Check Failed")
+  	    					.setMessage("Unauthorized use of this application not permitted. Please purchase from Google Play (only USD 99 cents!).")
+  	    					.setPositiveButton("Google Play", new DialogInterface.OnClickListener() {
+								
+								public void onClick(DialogInterface dialog, int which) {
+									Uri uri = Uri.parse("market://details?id=com.groza.wifiauto");
+									Intent intent = new Intent (Intent.ACTION_VIEW, uri); 
+									startActivity(intent);
+									
+								}
+							});
+  	    				break;
+  	    			default:
+  	    				break;
+  	    			}
+  	    			
+  	    			licenseDialog.show();
+  	    		}
+  	    	});
+  	    }
+  	    
+  	}
+  	
+  	protected void doCheck() {
+  		Toast toaster = Toast.makeText(WifiAutoToggleActivity.this, "Checking application license...", Toast.LENGTH_SHORT);
+	        toaster.show();
+  		mChecker.checkAccess(mLicenseCheckerCallback);
+  	}
+  	
+  	private boolean isCallable(Intent intent) {
+        List<ResolveInfo> list = getPackageManager().queryIntentActivities(intent, 
+            PackageManager.MATCH_DEFAULT_ONLY);
+        return list.size() > 0;
+  	}
+    
+    @Override
+    public void onResume() {
+    	super.onResume();
+    	serviceStatus();
+    }
+    
+    @Override
+    public void onDestroy() {
+    	super.onDestroy();
+    	mChecker.onDestroy();
+    }
+}
\ No newline at end of file
Index: src/com/nolnoch/wifiauto/WifiAutoToggleActivity.java
===================================================================
--- src/com/nolnoch/wifiauto/WifiAutoToggleActivity.java	(revision 13)
+++ src/com/nolnoch/wifiauto/WifiAutoToggleActivity.java	(working copy)

Property changes on: src/com/nolnoch/wifiauto/WifiAutoToggleActivity.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
